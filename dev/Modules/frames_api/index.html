<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · FrameTransformations.jl</title><meta name="title" content="Public API · FrameTransformations.jl"/><meta property="og:title" content="Public API · FrameTransformations.jl"/><meta property="twitter:title" content="Public API · FrameTransformations.jl"/><meta name="description" content="Documentation for FrameTransformations.jl."/><meta property="og:description" content="Documentation for FrameTransformations.jl."/><meta property="twitter:description" content="Documentation for FrameTransformations.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FrameTransformations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FrameTransformations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/gen/t00_frames/">01 - Frame System</a></li><li><a class="tocitem" href="../../Tutorials/gen/t01_axes/">02 - Axes</a></li><li><a class="tocitem" href="../../Tutorials/gen/t02_points/">03 - Points</a></li><li><a class="tocitem" href="../../Tutorials/gen/t03_eop/">04 - Loading EOP Data</a></li><li><a class="tocitem" href="../../Tutorials/gen/t04_lighttime/">05 - Light Time Corrections</a></li><li><a class="tocitem" href="../../Tutorials/gen/t05_multithread/">06 - Multithreading</a></li></ul></li><li><span class="tocitem">Use Cases</span><ul><li><a class="tocitem" href="../../Examples/gen/e01_cr3bp/">CR3BP</a></li><li><a class="tocitem" href="../../Examples/gen/e02_hifi/">High-Fidelity Earth-Moon Environment</a></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><span class="tocitem">Modules</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox" checked/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Frames</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Frame-System"><span>Frame System</span></a></li><li><a class="tocitem" href="#Axes"><span>Axes</span></a></li><li><a class="tocitem" href="#Points"><span>Points</span></a></li><li><a class="tocitem" href="#rotation_api"><span>Rotations</span></a></li><li><a class="tocitem" href="#Transformations"><span>Transformations</span></a></li></ul></li><li><a class="tocitem" href="../frames_lapi/">Low-level API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Orient</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../orient_api/">Public API</a></li><li><a class="tocitem" href="../orient_lapi/">Low-level API</a></li></ul></li></ul></li><li><a class="tocitem" href="../../roadmap/">Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li><a class="is-disabled">Frames</a></li><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/main/docs/src/Modules/frames_api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="basic_frames_api"><a class="docs-heading-anchor" href="#basic_frames_api">Frames&#39;s Public Documentation</a><a id="basic_frames_api-1"></a><a class="docs-heading-anchor-permalink" href="#basic_frames_api" title="Permalink"></a></h1><h2 id="Frame-System"><a class="docs-heading-anchor" href="#Frame-System">Frame System</a><a id="Frame-System-1"></a><a class="docs-heading-anchor-permalink" href="#Frame-System" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.FrameSystem" href="#FrameTransformations.Frames.FrameSystem"><code>FrameTransformations.Frames.FrameSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FrameSystem{O, T, S, E}</code></pre><p>A <code>FrameSystem</code> instance manages a collection of user-defined <code>FramePointNode</code> and  <code>FrameAxesNode</code> objects, enabling efficient computation of arbitrary transformations  between them. It is created by specifying the maximum transformation order <code>O</code>, the outputs  datatype <code>T</code> and an <code>AbstractTimeScale</code> instance <code>S</code>. Additionally, an <code>AbstractEphemerisProvider</code>  instance <code>E</code> can be provided to compute transformations that require ephemeris data. </p><p>The following transformation orders are accepted: </p><ul><li><strong>1</strong>: position </li><li><strong>2</strong>: position and velocity </li><li><strong>3</strong>: position, velocity and acceleration</li><li><strong>4</strong>: position, velocity, acceleration and jerk</li></ul><p>By specifying the maximum transformation the <code>FrameSystem</code> memory usage and performance can  be optimised and tailored to the user&#39;s needs.</p><hr/><pre><code class="nohighlight hljs">FrameSystem{O, T}()</code></pre><p>Create a <code>FrameSystem</code> object of order <code>O</code> and datatype <code>T</code>. The <code>BarycentricDynamicalTime</code>  is automatically assigned as the default time scale. The resulting object is constructed  with a <code>NullEphemerisProvider</code>, which does not allow the computation of transformation that  involve ephemeris files.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = FrameSystem{2, Float64}();

julia&gt; @axes ICRF 1 

julia&gt; @axes ECLIPJ2000 17 

julia&gt; add_axes_inertial!(F, ICRF)

julia&gt; add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)

julia&gt; rotation6(F, ICRF, ECLIPJ2000, 0.0)
Rotation{2, Float64}
[...]

julia&gt; rotation9(F, ICRF, ECLIPJ2000, 0.0)
ERROR: Insufficient frame system order: transformation requires at least order 3.
</code></pre><hr/><pre><code class="nohighlight hljs">FrameSystem{O, T, S}()</code></pre><p>Create a <code>FrameSystem</code> object of order <code>O</code>, datatype <code>T</code> and time scale <code>S</code>. The resulting  object is constructed with a <code>NullEphemerisProvider</code>, which does not allow the computation  of transformation that involve ephemeris files.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = FrameSystem{1, Float64, TerrestrialTime}();

julia&gt; @axes ICRF 1 

julia&gt; @axes ECLIPJ2000 17 

julia&gt; add_axes_inertial!(F, ICRF)

julia&gt; add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)

julia&gt; ep_tt = Epoch(&quot;2023-02-10T12:00:00 TT&quot;)
2023-02-10T12:00:00.000 TT

julia&gt; rotation3(F, ICRF, ECLIPJ2000, ep_tt)
Rotation{1,Float64}([...])

julia&gt; ep_tdb = Epoch(&quot;2023-02-10T12:00:00 TDB&quot;)
2023-02-10T12:00:00.000 TDB

julia&gt; rotation3(F, ICRF, ECLIPJ2000, ep_tdb)
ERROR: ArgumentError: Incompatible epoch timescale: expected TerrestrialTime, found BarycentricDynamicalTime.
[...]</code></pre><hr/><pre><code class="nohighlight hljs">FrameSystem{O, T}(eph::AbstractEphemerisProvider)</code></pre><p>Create a <code>FrameSystem</code> object of order <code>O</code> and datatype <code>T</code> by providing an instance of an  <code>AbstractEphemerisProvider</code> subtype. The timescale is automatically set to the one associated  to the ephemeris files loaded in <code>eph</code>. This constructor shall be used when the user desires  to compute transformations that involve ephemeris data. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All the kernels that will be used must be loaded within <code>eph</code>. Once the <code>FrameSystem</code>  has been created, no additional kernel can be added nor removed.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Ephemerides 

julia&gt; eph = EphemerisProvider(DE440_KERNEL_PATH);

julia&gt; F = FrameSystem{2, Float64}(eph)
FrameSystem{2, Float64, BarycentricDynamicalTime, EphemerisProvider}(
  eph: 1-kernel EphemerisProvider,
  points: EMPTY
  axes: EMPTY
)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a>, <a href="#FrameTransformations.Frames.add_point_root!"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.vector3"><code>vector3</code></a> and <a href="#FrameTransformations.Frames.rotation3"><code>rotation3</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/types.jl#L358-L469">source</a></section></article><h2 id="Axes"><a class="docs-heading-anchor" href="#Axes">Axes</a><a id="Axes-1"></a><a class="docs-heading-anchor-permalink" href="#Axes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.@axes" href="#FrameTransformations.Frames.@axes"><code>FrameTransformations.Frames.@axes</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@axes(name, id, type=nothing)</code></pre><p>Define a new axes instance to alias the given <code>id</code>. This macro creates an  <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> subtype and its singleton instance callen <code>name</code>. Its type name  is obtained by appending <code>Axes</code> to either <code>name</code> or <code>type</code> (if provided). </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; typeof(ICRF)
InternationalCelestialReferenceFrameAxes

julia&gt; axes_alias(ICRF) 
1

julia&gt; @axes IAU_EARTH 10013

julia&gt; typeof(IAU_EARTH)
IauEarthAxes</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.@point"><code>@point</code></a> and <a href="#FrameTransformations.Frames.axes_alias"><code>axes_alias</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L91-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.axes_alias" href="#FrameTransformations.Frames.axes_alias"><code>FrameTransformations.Frames.axes_alias</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">axes_alias(ax::AbstractFrameAxes)</code></pre><p>Return the axes ID. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.is_inertial" href="#FrameTransformations.Frames.is_inertial"><code>FrameTransformations.Frames.is_inertial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_inertial(frame::FrameSystem, axes::AbstractFrameAxes)
is_inertial(frame::FrameSystem, axesid::Int)</code></pre><p>Return true if the given axes are inertial, i.e., non rotating with respect to the root inertial  axes.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>FixedOffsetAxes with respect to an inertial set of axes, are also consired inertial.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.is_timefixed" href="#FrameTransformations.Frames.is_timefixed"><code>FrameTransformations.Frames.is_timefixed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_timefixed(frame::FrameSystem, axes::AbstractFrameAxes)
is_timefixed(frame::FrameSystem, axesid::Int)</code></pre><p>Return true if the given axes are time-fixed, i.e., their orientation does not change in  time with respect to the root inertial axes. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only <code>:InertialAxes</code> and <code>:FixedOffsetAxes</code> defined with respect to other inertial axes  are here considered as time fixed. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L54-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.ComputableAxesVector" href="#FrameTransformations.Frames.ComputableAxesVector"><code>FrameTransformations.Frames.ComputableAxesVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComputableAxesVector(from, to, order::Int)</code></pre><p>Store the properties required to retrieve the i-th order components of a  desired vector. Arguments <code>from</code> and <code>to</code> are the NAIFIDs or <code>AbstractFramePoint</code> instances  that define the observer and target points.</p><p>Only orders between 1 and 3 are supported.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @point SSB 0 SolarSystemBarycenter

julia&gt; @point Sun 10 

julia&gt; ComputableAxesVector(SSB, Sun, 1)
ComputableAxesVector(0, 10, 1)

julia&gt; ComputableAxesVector(0, 10, 1)
ComputableAxesVector(0, 10, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/types.jl#L36-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_bci2000!" href="#FrameTransformations.Frames.add_axes_bci2000!"><code>FrameTransformations.Frames.add_axes_bci2000!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_bci2000!(frames, axes::AbstractFrameAxes, center, data)</code></pre><p>Add <code>axes</code> as a set of Body-Centered Inertial (BCI) axes at J2000 relative to the <code>frames</code>  system. The center point (i.e., the reference body) is <code>center</code> and can either be the point  ID or an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> instance. <code>data</code> is a dictionary containing a parsed  <code>TPC</code> file. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The parent axes are automatically set to the ICRF (ID = 1). If the  ICRF is not defined in <code>frames</code>, an error is thrown.</p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_bci2000!(frames, name::Symbol, axesid::Int, cid::Int, data)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_fixedoffset!"><code>add_axes_fixedoffset!</code></a>, <a href="#FrameTransformations.Frames.add_axes_bcrtod!"><code>add_axes_bcrtod!</code></a> and <a href="../orient_api/#FrameTransformations.Orient.AXESID_ICRF"><code>Orient.AXESID_ICRF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/planets.jl#L114-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_bcrtod!" href="#FrameTransformations.Frames.add_axes_bcrtod!"><code>FrameTransformations.Frames.add_axes_bcrtod!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_bcrtod!(frames, axes::AbstractFrameAxes, center::AbstractFramePoint, data)</code></pre><p>Add <code>axes</code> as a set of Body-Centered Rotating (BCR), True-of-Date (TOD) axes to the  <code>frames</code> system. The center point (i.e., the reference body) is <code>center</code>. <code>data</code> is a dictionary  containing a parsed <code>TPC</code> file. These axes are the equivalent of SPICE&#39;s <code>IAU_&lt;BODY_NAME&gt;</code> frames.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The parent axes are automatically set to the ICRF (ID = 1). If the  ICRF is not defined in <code>frames</code>, an error is thrown.</p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_bcrtod!(frames, name::Symbol, axesid::Int, cname::Symbol, cid::Int, data)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro and of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> via the <a href="#FrameTransformations.Frames.@point"><code>@point</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_rotating!"><code>add_axes_rotating!</code></a>, <a href="#FrameTransformations.Frames.add_axes_bci2000!"><code>add_axes_bci2000!</code></a> and <a href="../orient_api/#FrameTransformations.Orient.AXESID_ICRF"><code>Orient.AXESID_ICRF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/planets.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_computable!" href="#FrameTransformations.Frames.add_axes_computable!"><code>FrameTransformations.Frames.add_axes_computable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_computable!(frames, axes, parent, v1, v2, seq::Symbol)</code></pre><p>Add <code>axes</code> as a set of computable axes to <code>frames</code>. Computable axes differ from rotating axes  because they are computed through two vectors that are defined within the frame system itself.  Computable axes are the equivalent of SPICE&#39;s parameterized two-vector frames. </p><p>These axes are built such that the first vector, known as the primary vector, is parallel to  one axis of the frame; the component of the secondary vector orthogonal to the first is parallel to another axis of the frame, and the cross product of the two vectors is parallel to the  remaining axis. </p><p>The primary and secondary vectors, <code>v1</code> and <code>v2</code> are instances of <code>ComputableAxesVector</code>,  which is used to define the NAIF IDs of the vector origin and target, and its order. Current  accepted order values are: 1 (position), 2 (velocity) and 3 (acceleration). </p><p>For example, to define a primary vector that is parallel to the Sun&#39;s (NAIF ID = 10) velocity  with respect to the Solary system barycenter (NAIF ID = 0), <code>v1</code> must be set as:  <code>v1 = ComputableAxesVector(10, 0, 1)</code>.</p><p><code>seq</code> is a combination of two letters that is used to identify the desired pointing  directions of the primary and secondary vectors. Accepted sequences are: <code>:XY</code>, <code>:YX</code>, <code>:XZ</code>, <code>:ZX</code>, <code>:YZ</code> and <code>:ZY</code>. </p><p>Given a spacecraft registered as a point in the frame system, an example of a set of computable  axes is the Local Vertical Local Horizon (LVLH), where the spacecraf&#39;s nadir direction and  velocity direction define the axes orientation.  </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Regardless of the original set of axes in which the primary and secondary vectors are  defined, the axes orientation is automatically computed by rotating them to <code>parent</code>.</p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_computable!(frames, name::Symbol, axesid::Int, parentid::Int, v1, v2, seq)</code></pre><p>Low-level function to add axes <code>name</code> with id <code>axesid</code> to <code>frames</code> as computable axes without  requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Ephemerides 

julia&gt; eph = EphemerisProvider(DE440_KERNEL_PATH);

julia&gt; FRAMES = FrameSystem{4, Float64}(eph);

julia&gt; @point SSB 0 SolarySystemBarycenter 

julia&gt; @point Sun 10 

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame 

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; add_point_root!(FRAMES, SSB, ICRF)

julia&gt; add_point_ephemeris!(FRAMES, Sun)

julia&gt; @axes SunFrame 2

julia&gt; v1 = ComputableAxesVector(10, 0, 1)
ComputableAxesVector(10, 0, 1)

julia&gt; v2 = ComputableAxesVector(10, 0, 2)
ComputableAxesVector(10, 0, 2)

julia&gt; add_axes_computable!(FRAMES, SunFrame, ICRF, v1, v2, :XY)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.ComputableAxesVector"><code>ComputableAxesVector</code></a>, <a href="#FrameTransformations.Frames.add_axes_fixedoffset!"><code>add_axes_fixedoffset!</code></a>, <a href="#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a>  and <a href="#FrameTransformations.Frames.add_axes_computable!"><code>add_axes_computable!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L563-L636">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_eclipj2000!" href="#FrameTransformations.Frames.add_axes_eclipj2000!"><code>FrameTransformations.Frames.add_axes_eclipj2000!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_eclipj2000!(frames, axes::AbstractFrameAxes, parent, iau_model::IAUModel=iau1980)</code></pre><p>Add <code>axes</code> as a set of inertial axes representing the Ecliptic Equinox of J2000 (ECLIPJ2000) to <code>frames</code>. The obliquity of the ecliptic is computed using the IAU Model <code>iau_model</code>.</p><p>The admissed <code>parent</code> set of axes are the following: </p><ul><li><strong>ICRF</strong>: for the International Celestial Reference Frame, with ID = 1</li><li><strong>MEME2000</strong>: the Mean Earth/Moon Ephemeris of J2000, with ID = 22</li></ul><hr/><pre><code class="nohighlight hljs">add_axes_eclipj2000!(frames, name::Symbol, parentid::Int, iau_model::IAUModel=iau1980, 
    axesid::Int = Orient.AXESID_ECLIPJ2000)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; @axes ECLIPJ2000 17 EclipticEquinoxJ2000 

julia&gt; FRAMES = FrameSystem{1, Float64}();

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; add_axes_eclipj2000!(FRAMES, ECLIPJ2000, ICRF)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a> and <a href="../orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_MEME2000"><code>Orient.DCM_ICRF_TO_MEME2000</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/ecliptic.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_ephemeris!" href="#FrameTransformations.Frames.add_axes_ephemeris!"><code>FrameTransformations.Frames.add_axes_ephemeris!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_ephemeris!(frames, axes, rot_seq::Symbol)
add_axes_ephemeris!(frames, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)</code></pre><p>Add <code>axes</code> as a set of ephemeris axes to <code>frames</code>. The orientation of these axes is computed  with a series of 3 rotations specified by <code>rot_seq</code>. The euler angles and their derivatives  needed by the rotation are extracted from the ephemeris kernels loaded in <code>frames</code>. The parent axes are automatically assigned to the axes with respect to which the orientation  data has been written in the kernels.</p><p>This operation is only possible if the ephemeris kernels loaded within <code>frames</code> contain  orientation data for the AXES ID associated to <code>axes</code>. An error is returned if the parent  axes ID is yet to be added to <code>frames.</code></p><p>The rotation sequence is defined by a <code>Symbol</code> specifing the rotation axes. This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <strong>i-th</strong> rotation.  The possible <code>rot_seq</code> values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>,  <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, or <code>:ZYZ</code>.</p><p>Alternatively, one can provide custom functions that take a vector of euler angles and their  derivatives and return the DCM and its derivatives. </p><p>The input functions must accept only time as argument and their outputs must be as follows: </p><ul><li><strong>fun</strong>: return a Direction Cosine Matrix (DCM).</li><li><strong>δfun</strong>: return the DCM and its 1st order time derivative.</li><li><strong>δ²fun</strong>: return the DCM and its 1st and 2nd order time derivatives.</li><li><strong>δ³fun</strong>: return the DCM and its 1st, 2nd and 3rd order time derivatives.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the axes ID assigned by the user are aligned with those used to  generate the ephemeris kernels. No check are performed on whether these IDs represent  the same physical axes that are intended in the kernels.</p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_ephemeris!(frames, name::Symbol, axesid::Int, rot_seq::Symbol)
add_axes_ephemeris!(frames, name::Symbol, axesid::Int, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)</code></pre><p>Low-level functions to add axes <code>name</code> with id <code>axesid</code> to <code>frames</code> as ephemeris axes without  requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.ComputableAxesVector"><code>ComputableAxesVector</code></a>, <a href="#FrameTransformations.Frames.add_axes_fixedoffset!"><code>add_axes_fixedoffset!</code></a>, <a href="#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a>  and <a href="#FrameTransformations.Frames.add_axes_computable!"><code>add_axes_computable!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L736-L781">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_fixedoffset!" href="#FrameTransformations.Frames.add_axes_fixedoffset!"><code>FrameTransformations.Frames.add_axes_fixedoffset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_fixedoffset!(frames::FrameSystem, axes, parent, dcm::DCM)</code></pre><p>Add <code>axes</code> as a set of fixed offset axes to <code>frames</code>. Fixed offset axes have a constant  orientation with respect to their <code>parent</code> axes, represented by <code>dcm</code>, a  Direction Cosine Matrix (DCM).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>While inertial axes do not rotate with respect to the star background, fixed offset axes  are only constant with respect to their parent axes, but might be rotating with respect  to some other inertial axes.</p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_fixedoffset!(frames, name::Symbol, axesid::Int, parentid::Int, dcm:DCM)</code></pre><p>Low-level function to add axes <code>name</code> with id <code>axesid</code> to <code>frames</code> with a fixed-offset from  <code>parentid</code> without requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type via the  <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{1, Float64}();

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame 

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @axes ECLIPJ2000 17 

julia&gt; add_axes_fixedoffset!(FRAMES, ECLIPJ2000, ICRF, angle_to_dcm(π/3, :Z))</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_rotating!"><code>add_axes_rotating!</code></a>, <a href="#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a> and <a href="#FrameTransformations.Frames.add_axes_computable!"><code>add_axes_computable!</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L370-L405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_gcrf!" href="#FrameTransformations.Frames.add_axes_gcrf!"><code>FrameTransformations.Frames.add_axes_gcrf!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_gcrf!(frames::FrameSystem)</code></pre><p>Add the Geocentric Celestial Reference Frame (GCRF) to the frames graph. The axes are  automatically named <code>GCRF</code> and assigned the 23 ID. These axes can only  be defined as a set of root axes or as child of the ICRF (ID = 1).</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a>, <a href="#FrameTransformations.Frames.add_axes_icrf!"><code>add_axes_icrf!</code></a> and <a href="../orient_api/#FrameTransformations.Orient.AXESID_GCRF"><code>Orient.AXESID_GCRF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/common.jl#L29-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_inertial!" href="#FrameTransformations.Frames.add_axes_inertial!"><code>FrameTransformations.Frames.add_axes_inertial!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_inertial!(frames, axes; parent=nothing, dcm=nothing)</code></pre><p>Add <code>axes</code> as a set of inertial axes to <code>frames</code>. Only inertial axes can be used as root axes  to initialise the axes graph. Only after the addition of a set of inertial axes, other axes  classes may be added aswell. Once a set of root-axes has been added, <code>parent</code> and <code>dcm</code>  become mandatory fields.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The parent of a set of inertial axes must also be inertial. FixedOffset axes that are  that only have inertial parents are also accepted.</p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_inertial!(frames, name::Symbol, axesid::Int; parentid=nothing, dcm=nothing)</code></pre><p>Low-level function to add axes <code>name</code> with id <code>axesid</code> to <code>frames</code> without requiring the  creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame 

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @axes ECLIPJ2000 17 

julia&gt; add_axes_inertial!(FRAMES, ECLIPJ2000)
ERROR: A set of parent axes for ECLIPJ2000 is required
[...]

julia&gt; add_axes_inertial!(FRAMES, ECLIPJ2000; parent=ICRF, dcm=angle_to_dcm(π/3, :Z))</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_rotating!"><code>add_axes_rotating!</code></a>, <a href="#FrameTransformations.Frames.add_axes_fixedoffset!"><code>add_axes_fixedoffset!</code></a> and <a href="#FrameTransformations.Frames.add_axes_computable!"><code>add_axes_computable!</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L267-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_icrf!" href="#FrameTransformations.Frames.add_axes_icrf!"><code>FrameTransformations.Frames.add_axes_icrf!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_icrf!(frames::FrameSystem)</code></pre><p>Add the International Celestial Reference Frame (ICRF) as the root axes of the frames graph. The axes are automatically named <code>ICRF</code> and assigned the 1 ID. </p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a>, <a href="#FrameTransformations.Frames.add_axes_gcrf!"><code>add_axes_gcrf!</code></a> and <a href="../orient_api/#FrameTransformations.Orient.AXESID_ICRF"><code>Orient.AXESID_ICRF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/common.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_itrf!" href="#FrameTransformations.Frames.add_axes_itrf!"><code>FrameTransformations.Frames.add_axes_itrf!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_itrf!(frames, axes::AbstractFrameAxes, parent, model::IAU2006Model=iau2006b)</code></pre><p>Add <code>axes</code> as a set of axes representing the International Terrestrial Reference Frame (ITRF) to <code>frames</code>. Use the <code>model</code> argument to specify which IAU model model should be used for  the computations. The default is set to <code>iau2006b</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If the ID of the parent set of <code>axes</code> is neither the ICRF (ID = 1) nor the GCRF (ID = 23), an error is thrown. </p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_itrf!(frames, name::Symbol, parentid::Int, model::IAU2006Model=iau2006b, 
    axesid::Int = Orient.AXESID_ITRF)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_rotating!"><code>add_axes_rotating!</code></a> and <a href="../orient_api/#FrameTransformations.Orient.orient_rot3_itrf_to_gcrf"><code>orient_rot3_itrf_to_gcrf</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/earth.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_me421!" href="#FrameTransformations.Frames.add_axes_me421!"><code>FrameTransformations.Frames.add_axes_me421!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_me421!(frames, axes::AbstractFrameAxes, parent)</code></pre><p>Add <code>axes</code> as fixed offset axes representing the DE421 Moon&#39;s Mean Earth/Mean Rotation (ME)  to <code>frames</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>parent</code> set of axes must either the DE440 Principal Axes (PA440, ID = </p><ol><li>or the DE421 Principal Axes (PA421, ID = </li></ol><p>31006), otherwise an error is thrown. Depending on that, the  relative axes orientation will be automatically selected by this function. </p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_me421!(frames, name::Symbol, parentid::Int, axesid::Int = Orient.AXESID_MOONME_DE421)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_pa440!"><code>add_axes_pa440!</code></a>, and <a href="#FrameTransformations.Frames.add_axes_pa421!"><code>add_axes_pa421!</code></a>,  <a href="../orient_api/#FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421"><code>Orient.DCM_MOON_PA421_TO_ME421</code></a> and <a href="../orient_api/#FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421"><code>Orient.DCM_MOON_PA421_TO_ME421</code></a>, </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/moon.jl#L122-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_meme2000!" href="#FrameTransformations.Frames.add_axes_meme2000!"><code>FrameTransformations.Frames.add_axes_meme2000!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_meme2000!(frames, axes::AbstractFrameAxes, parent)</code></pre><p>Add <code>axes</code> as a set of inertial axes representing the Mean Equator Mean Equinox of J2000  to <code>frames</code>. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The the axes ID of the parent set of axes must be 1 (ICRF) or  17 (ECLIPJ2000) otherwise and error is thrown.</p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_meme2000!(frames, name::Symbol, parentid::Int, axesid::Int = Orient.AXESID_MEME2000)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; @axes MEME2000 22 MeanEquatorMeanEquinoxJ2000 

julia&gt; FRAMES = FrameSystem{1, Float64}();

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; add_axes_meme2000!(FRAMES, MEME2000, ICRF)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a> and <a href="../orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_MEME2000"><code>Orient.DCM_ICRF_TO_MEME2000</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/common.jl#L62-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_mod!" href="#FrameTransformations.Frames.add_axes_mod!"><code>FrameTransformations.Frames.add_axes_mod!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_mod!(frames, axes::AbstractFrameAxes, parent)</code></pre><p>Add <code>axes</code> as a set of projected axes representing the Mean Equator and Equinox of Date (MOD) to <code>frames</code>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The ID of the <code>parent</code> set of axes must be 1 (ICRF),  otherwise an error is thrown. </p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_mod!(frames, name::Symbol, axesid::Int, parentid::Int)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_projected!"><code>add_axes_projected!</code></a> and <a href="../orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_mod"><code>Orient.orient_rot3_icrf_to_mod</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/common.jl#L127-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_tod!" href="#FrameTransformations.Frames.add_axes_tod!"><code>FrameTransformations.Frames.add_axes_tod!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_tod!(frames, axes::AbstractFrameAxes, parent)</code></pre><p>Add <code>axes</code> as a set of projected axes representing the True Equator of Date (TOD) to <code>frames</code>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The ID of the <code>parent</code> set of axes must be 1 (ICRF),  otherwise an error is thrown. </p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_tod!(frames, name::Symbol, axesid::Int, parentid::Int)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_projected!"><code>add_axes_projected!</code></a> and <a href="../orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_tod"><code>Orient.orient_rot3_icrf_to_tod</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/common.jl#L173-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_teme!" href="#FrameTransformations.Frames.add_axes_teme!"><code>FrameTransformations.Frames.add_axes_teme!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_teme!(frames, axes::AbstractFrameAxes, parent)</code></pre><p>Add <code>axes</code> as a set of projected axes representing the True Equator, Mean Equinox (TEME) to <code>frames</code>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The ID of the <code>parent</code> set of axes must be 1 (ICRF),  otherwise an error is thrown. </p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_teme!(frames, name::Symbol, axesid::Int, parentid::Int)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_projected!"><code>add_axes_projected!</code></a> and <a href="../orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_teme"><code>Orient.orient_rot3_icrf_to_teme</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/common.jl#L219-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_pef!" href="#FrameTransformations.Frames.add_axes_pef!"><code>FrameTransformations.Frames.add_axes_pef!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_pef!(frames, axes::AbstractFrameAxes, parent)</code></pre><p>Add <code>axes</code> as a set of rotating axes representing the Pseudo Earth Fixed (PEF) axes to <code>frames</code>. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The ID of the <code>parent</code> set of axes must be 1 (ICRF),  otherwise an error is thrown. </p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_pef!(frames, name::Symbol, axesid::Int, parentid::Int)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_rotating!"><code>add_axes_rotating!</code></a>, <a href="../orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_pef"><code>Orient.orient_rot3_icrf_to_pef</code></a> and  <a href="../orient_lapi/#FrameTransformations.Orient.orient_rot6_icrf_to_pef"><code>Orient.orient_rot6_icrf_to_pef</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/common.jl#L265-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_pa421!" href="#FrameTransformations.Frames.add_axes_pa421!"><code>FrameTransformations.Frames.add_axes_pa421!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_pa421!(frames, axes::AbstractFrameAxes)</code></pre><p>Add <code>axes</code> as a set of ephemeris axes representing the DE421 Moon&#39;s Principal Axes (PA) to  <code>frames</code>. The libration angles are extracted from the ephemeris kernels loaded within <code>frames</code>,  an error is thrown if such orientation data is not available. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>To properly read the ephemeris kernels, the ID associated to the input <code>axes</code> must match  NAIF&#39;s FRAME ID for the Moon PA DE421 axes (31006).</p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_pa421!(frames, name::Symbol, axesid::Int = Orient.AXESID_MOONPA_DE421)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="../orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE421"><code>Orient.AXESID_MOONPA_DE421</code></a>, <a href="../orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa421"><code>Orient.orient_rot3_icrf_to_pa421</code></a>,  <a href="#FrameTransformations.Frames.add_axes_pa440!"><code>add_axes_pa440!</code></a>, and <a href="#FrameTransformations.Frames.add_axes_me421!"><code>add_axes_me421!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/moon.jl#L62-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_pa440!" href="#FrameTransformations.Frames.add_axes_pa440!"><code>FrameTransformations.Frames.add_axes_pa440!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_pa440!(frames, axes::AbstractFrameAxes)</code></pre><p>Add <code>axes</code> as a set of ephemeris axes representing the DE440 Moon&#39;s Principal Axes (PA) to  <code>frames</code>. The libration angles are extracted from the ephemeris kernels loaded within <code>frames</code>,  an error is thrown if such orientation data is not available. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>To properly read the ephemeris kernels, the ID associated to the input <code>axes</code> must match  NAIF&#39;s FRAME ID for the Moon PA DE440 axes (31008).</p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_pa440!(frames, name::Symbol, axesid::Int = Orient.AXESID_MOONPA_DE440)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type  via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="../orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE440"><code>Orient.AXESID_MOONPA_DE440</code></a>, <a href="../orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa440"><code>Orient.orient_rot3_icrf_to_pa440</code></a> and <a href="#FrameTransformations.Frames.add_axes_pa421!"><code>add_axes_pa421!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/moon.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_projected!" href="#FrameTransformations.Frames.add_axes_projected!"><code>FrameTransformations.Frames.add_axes_projected!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_projected!(frames, axes, parent, fun)</code></pre><p>Add <code>axes</code> as a set of projected axes to <code>frames</code>. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. </p><p>Projected axes are similar to rotating axis, except that all the positions, velocity, etc ...  are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null,  despite the rotation depends on time).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the input function and their outputs have the correct signature. This  function does not perform any checks on the output types. </p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_projected!(frames, name::Symbol, axesid::Int, parentid::Int, fun)</code></pre><p>Low-level function to add axes <code>name</code> with id <code>axesid</code> to <code>frames</code> as projected axes without  requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L693-L713">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_rotating!" href="#FrameTransformations.Frames.add_axes_rotating!"><code>FrameTransformations.Frames.add_axes_rotating!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_rotating!(frames, axes, parent, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)</code></pre><p>Add <code>axes</code> as a set of rotating axes to <code>frames</code>. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. </p><p>The input functions must accept only time as argument and their outputs must be as follows: </p><ul><li><strong>fun</strong>: return a Direction Cosine Matrix (DCM).</li><li><strong>δfun</strong>: return the DCM and its 1st order time derivative.</li><li><strong>δ²fun</strong>: return the DCM and its 1st and 2nd order time derivatives.</li><li><strong>δ³fun</strong>: return the DCM and its 1st, 2nd and 3rd order time derivatives.</li></ul><p>If <code>δfun</code>, <code>δ²fun</code> or <code>δ³fun</code> are not provided, they are computed via automatic differentiation.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types. </p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_rotating!(frames, name::Symbol, axesid::Int, parentid::Int, fun, δfun=nothing, 
    δ²fun=nothing, δ³fun=nothing)</code></pre><p>Low-level function to add axes <code>name</code> with id <code>axesid</code> to <code>frames</code> as rotating axes without  requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> type via the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{3, Float64}();

julia&gt; @axes Inertial 1

julia&gt; add_axes_inertial!(FRAMES, Inertial)

julia&gt; @axes Synodic 2 

julia&gt; fun(t) = angle_to_dcm(t, :Z);

julia&gt; add_axes_rotating!(FRAMES, Synodic, Inertial, fun)

julia&gt; R = rotation6(FRAMES, Inertial, Synodic, π/6);

julia&gt; R[1]
DCM{Float64}:
  0.866025  0.5       0.0
 -0.5       0.866025  0.0
  0.0       0.0       1.0

julia&gt; R[2]
DCM{Float64}:
 -0.5        0.866025  0.0
 -0.866025  -0.5       0.0
  0.0        0.0       0.0</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_fixedoffset!"><code>add_axes_fixedoffset!</code></a>, <a href="#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a> and <a href="#FrameTransformations.Frames.add_axes_computable!"><code>add_axes_computable!</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/axes.jl#L425-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_axes_topocentric!" href="#FrameTransformations.Frames.add_axes_topocentric!"><code>FrameTransformations.Frames.add_axes_topocentric!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_axes_topocentric!(frames, axes::AbstractFrameAxes, parent, λ::Number, ϕ::Number, type::Symbol)</code></pre><p>Add <code>axes</code> as a set of fixed-offset topocentric axes to <code>frames</code>. The orientation relative  to the parent axes <code>parent</code> is defined throuh the longitude <code>λ</code>, the geodetic latitude <code>ϕ</code>  and the type <code>type</code>, which may be any of the following: </p><ul><li><strong>:NED</strong> (North, East, Down): the X-axis points North, the Y-axis is directed eastward and    the Z-axis points inwards towards the nadir.</li><li><strong>:SEZ</strong> (South, East, Zenith): the X-axis points South, the Y-axis is directed East, and    the Z-axis points outwards towards the zenith.</li><li><strong>:ENU</strong> (East, North, Up): the X-axis points East, the Y-axis is directed North and the    Z-axis points outwards towards the zenith. </li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>parent</code> axes must be a set of body-fixed reference axes. When this constraint is  not satisfied, the results may be fundamentally wrong. </p></div></div><hr/><pre><code class="nohighlight hljs">add_axes_topocentric!(frames, name::Symbol, axesid::Int, parentid::Int, λ, ϕ, type)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> via  the <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_fixedoffset!"><code>add_axes_fixedoffset!</code></a> and <a href="#FrameTransformations.Frames.add_point_surface!"><code>add_point_surface!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/topocentric.jl#L3-L30">source</a></section></article><h2 id="Points"><a class="docs-heading-anchor" href="#Points">Points</a><a id="Points-1"></a><a class="docs-heading-anchor-permalink" href="#Points" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.@point" href="#FrameTransformations.Frames.@point"><code>FrameTransformations.Frames.@point</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@point(name, id, type=nothing)</code></pre><p>Define a new point instance to alias the given NAIFID <code>id</code>. This macro creates an  <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> subtype and its singleton instance called <code>name</code>. Its type name  is obtained by appending <code>Point</code> to either <code>name</code> or <code>type</code> (if provided).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @point Venus 299

julia&gt; typeof(Venus)
VenusPoint 

julia&gt; point_alias(Venus)
299

julia&gt; @point EMB 3 EarthMoonBarycenter

julia&gt; typeof(EMB) 
EarthMoonBarycenterPoint

julia&gt; point_alias(EMB) 
3 </code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> and <a href="#FrameTransformations.Frames.point_alias"><code>point_alias</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/points.jl#L32-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.point_alias" href="#FrameTransformations.Frames.point_alias"><code>FrameTransformations.Frames.point_alias</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_alias(ax::AbstractFramePoint)</code></pre><p>Return the NAIF ID associated to the input point. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/points.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_point_dynamical!" href="#FrameTransformations.Frames.add_point_dynamical!"><code>FrameTransformations.Frames.add_point_dynamical!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point_dynamical!(frames, point::AbstractFramePoint, parent, axes, fun, δfun=nothing, 
    δ²fun=nothing, δ³fun=nothing)</code></pre><p>Add <code>point</code> as a time point to <code>frames</code>. The state vector for these points depends only on  time and is computed through the custom functions provided by the user. <code>axes</code> is the ID or  <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> instance in which the point state-vector is expressed.</p><p>The input functions must accept only time as argument and their outputs must be as follows: </p><ul><li><strong>fun</strong>: return a 3-elements vector: position</li><li><strong>δfun</strong>: return a 6-elements vector: position and velocity</li><li><strong>δ²fun</strong>: return a 9-elements vector: position, velocity and acceleration</li><li><strong>δ³fun</strong>: return a 12-elements vector: position, velocity, acceleration and jerk</li></ul><p>If <code>δfun</code>, <code>δ²fun</code> or <code>δ³fun</code> are not provided, they are computed with automatic differentiation. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the input functions and their ouputs have the correct signature. This  function does not perform any checks on whether the returned vectors have the appropriate  dimensions. </p></div></div><hr/><pre><code class="nohighlight hljs">add_point_dynamical!(frames, name::Symbol, pointid::Int, parentid::Int, axes, fun, 
    δfun=nothing, δ²fun=nothing, δ³fun=nothing)</code></pre><p>Low-level function to add point <code>name</code> with ID <code>id</code> to <code>frames</code> as a dynamical point without  requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> type via the <a href="#FrameTransformations.Frames.@point"><code>@point</code></a> macro. <code>axes</code> is the ID or <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> instance in which the point state-vector is  expressed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}()

julia&gt; @axes ICRF 1 

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point Origin 0 

julia&gt; add_point_root!(FRAMES, Origin, ICRF)

julia&gt; @point Satellite 1 

julia&gt; satellite_pos(t::T) where T = [cos(t), sin(t), 0]

julia&gt; add_point_dynamical!(FRAMES, Satellite, Origin, ICRF, satellite_pos)

julia&gt; vector6(FRAMES, Origin, Satellite, ICRF, π/6)
6-element SVector{6, Float64} with indices SOneTo(6):
  0.8660254037844387
  0.49999999999999994
  0.0
 -0.49999999999999994
  0.8660254037844387
  0.0</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_root!"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.add_point_ephemeris!"><code>add_point_ephemeris!</code></a>,<a href="#FrameTransformations.Frames.add_point_fixed!"><code>add_point_fixed!</code></a> and <a href="#FrameTransformations.Frames.add_point_updatable!"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/points.jl#L599-L663">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_point_ephemeris!" href="#FrameTransformations.Frames.add_point_ephemeris!"><code>FrameTransformations.Frames.add_point_ephemeris!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point_ephemeris!(frames::FrameSystem, point::AbstractFramePoint)</code></pre><p>Add <code>point</code> as an ephemeris point to <code>frames</code>. This function is intended for points whose  state-vector is read from ephemeris kernels (i.e., de440.bsp). The parent point is  automatically assigned to the point with respect to which the ephemeris data is written  in the kernels. If that point is not available as an ephemeris point in the frame system,  an error is thrown.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The axes in which the state-vector is expressed are taken from the ephemeris data: an  error is returned if the axes ID is yet to be added to <code>frames</code>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the NAIF ID and the axes ID assigned by the user are aligned with  those used to generate the ephemeris kernels. No check are performed on whether these IDs represent the same physical bodies and axes that are intended in the kernels.</p></div></div><hr/><pre><code class="nohighlight hljs">add_point_ephemeris!(frames::FrameSystem, name::Symbol, naifid::Int)</code></pre><p>Low-level function to add point <code>name</code> with ID <code>id</code> to <code>frames</code> as an ephemeris point without  requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> type via the <a href="#FrameTransformations.Frames.@point"><code>@point</code></a> macro.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Ephemerides 

julia&gt; eph = EphemerisProvider(DE440_KERNEL_PATH);

julia&gt; FRAMES = FrameSystem{2, Float64}(eph);

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point SSB 0 SolarSystemBarycenter

julia&gt; @point Sun 10 

julia&gt; add_point_root!(FRAMES, SSB, ICRF)

julia&gt; add_point_ephemeris!(FRAMES, Sun)

julia&gt; @point Jupiter 599

julia&gt; add_point_ephemeris!(FRAMES, Jupiter)
ERROR: ArgumentError: Ephemeris data for NAIFID 599 is not available in the kernels loaded in the given FrameSystem.
[...]</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_root!"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.add_point_fixed!"><code>add_point_fixed!</code></a>, <a href="#FrameTransformations.Frames.add_point_dynamical!"><code>add_point_dynamical!</code></a> and <a href="#FrameTransformations.Frames.add_point_updatable!"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/points.jl#L289-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_point_fixed!" href="#FrameTransformations.Frames.add_point_fixed!"><code>FrameTransformations.Frames.add_point_fixed!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point_fixed!(frames, point::AbstractFramePoint, parent, axes, offset::AbstractVector)</code></pre><p>Add <code>point</code> as a fixed point to <code>frames</code>. Fixed points are those whose positions have a  constant <code>offset</code> with respect their <code>parent</code> points in the given set of <code>axes</code>. Thus, points  eligible for this class must have null velocity and acceleration with respect to <code>parent</code>. <code>axes</code> is the ID or <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> instance in which the point state-vector is  expressed.</p><hr/><pre><code class="nohighlight hljs">add_point_fixed!(frames, name::Symbol, pointid::Int, parentid::Int, axes, offset::AbstractVector)</code></pre><p>Low-level function to add point <code>name</code> with ID <code>id</code> to <code>frames</code> as a fixed-point with respect  to point <code>parentid</code> without requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> type  via the <a href="#FrameTransformations.Frames.@point"><code>@point</code></a> macro. <code>axes</code> is the ID or <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> instance in  which the point state-vector is expressed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();

julia&gt; @axes SF -3000 SatelliteFrame

julia&gt; add_axes_inertial!(FRAMES, SF)

julia&gt; @point SC -10000 Spacecraft

julia&gt; @point SolarArrayCenter -10001

julia&gt; add_point_root!(FRAMES, SC, SF)

julia&gt; sa_offset = [0.10, 0.15, 0.30];

julia&gt; add_point_fixed!(FRAMES, SolarArrayCenter, SC, SF, sa_offset)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_root!"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.add_point_ephemeris!"><code>add_point_ephemeris!</code></a>,  <a href="#FrameTransformations.Frames.add_point_dynamical!"><code>add_point_dynamical!</code></a> and <a href="#FrameTransformations.Frames.add_point_updatable!"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/points.jl#L444-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_point_root!" href="#FrameTransformations.Frames.add_point_root!"><code>FrameTransformations.Frames.add_point_root!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point_root!(frames::FramesSystem, point::AbstractFramePoint, axes)</code></pre><p>Add <code>point</code> as a root point to <code>frames</code> to initialize the points graph. Only after the  addition of a root point, other points may be added aswell. This point is intended as the origin, i.e., its position will equal (0., 0., 0.). <code>axes</code> is the ID or <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> instance in which the point state-vector is expressed.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This operation can be performed only once per <a href="#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object: multiple root  points in the same graph are both inadmissible and meaningless.</p></div></div><hr/><pre><code class="nohighlight hljs">add_point_root!(frames::FrameSystem, name::Symbol, pointid::Int, axes)</code></pre><p>Low-level function to add point <code>name</code> with ID <code>pointid</code> to <code>frames</code> as a root-point without  requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> type via the <a href="#FrameTransformations.Frames.@point"><code>@point</code></a> macro. <code>axes</code> is the ID or <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> instance in which the point state-vector is  expressed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point SSB 0 SolarSystemBarycenter 

julia&gt; add_point_root!(FRAMES, SSB, ICRF)

julia&gt; @point Sun 10

julia&gt; add_point_root!(FRAMES, Sun, ICRF)
ERROR: ArgumentError: A root-point is already registed in the given FrameSystem.
[...]</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_ephemeris!"><code>add_point_ephemeris!</code></a>, <a href="#FrameTransformations.Frames.add_point_fixed!"><code>add_point_fixed!</code></a>, <a href="#FrameTransformations.Frames.add_point_dynamical!"><code>add_point_dynamical!</code></a> and <a href="#FrameTransformations.Frames.add_point_updatable!"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/points.jl#L226-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_point_surface!" href="#FrameTransformations.Frames.add_point_surface!"><code>FrameTransformations.Frames.add_point_surface!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point_surface!(frames, point::AbstractFramePoint, parent, axes, λ::Number, 
    ϕ::Number, R::Number, f::Number=0.0, h::Number=0.0)</code></pre><p>Add <code>point</code> to <code>frames</code> as a fixed point on the surface of the <code>parent</code> point body. The relative  position is specified by the longitude <code>λ</code>, the geodetic latitude <code>ϕ</code>, the reference radius  of the ellipsoid <code>R</code> and its flattening <code>f</code>. The altitude over the reference surface of the  ellipsoid <code>h</code> defaults to 0. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>axes</code> must be a set of body-fixed reference axes for the body represented by <code>parent</code>.  When this constraint is not satisfied, the results may be fundamentally wrong. </p></div></div><hr/><pre><code class="nohighlight hljs">add_point_surface!(frames, point::AbstractFramePoint, parent, axes, pck,  λ, ϕ, h::Number=0.0)</code></pre><p>In this case, the ellipsoid parameters are extracted from the input TPC kernel <code>pck</code> using  the NAIFId associated to the <code>parent</code> point.</p><hr/><pre><code class="nohighlight hljs">add_point_surface!(frames, name::Symbol, pointid::Int, parentid::Int, axesid::Int, 
    λ::Number, ϕ::Number, R::Number, f::Number=0.0, h::Number=0.0,)</code></pre><p>Low-level function to avoid requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> via  the <a href="#FrameTransformations.Frames.@point"><code>@point</code></a> macro.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_fixed!"><code>add_point_fixed!</code></a> and <a href="#FrameTransformations.Frames.add_axes_topocentric!"><code>add_axes_topocentric!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/Definitions/topocentric.jl#L63-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.add_point_updatable!" href="#FrameTransformations.Frames.add_point_updatable!"><code>FrameTransformations.Frames.add_point_updatable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point_updatable!(frames, point::AbstractFramePoint, parent, axes)</code></pre><p>Add <code>point</code> as an updatable point to <code>frames</code>. Differently from all the other classes, the  state vector for updatable points (expressed in the set of input <code>axes</code>) must be manually  updated before being used for other computations. <code>axes</code> is the ID or  <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> instance in which the point state-vector is expressed. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This class of points becomes particularly useful if the state vector is not known a-priori,  e.g., when it is the output of an optimisation process which exploits the frame system.</p></div></div><hr/><pre><code class="nohighlight hljs">add_point_updatable!(frames, name::Symbol, pointid::Int, parentid::Int, axes)</code></pre><p>Low-level function to add point <code>name</code> with ID <code>id</code> to <code>frames</code> as an updatable point without  requiring the creation of an <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> type via the <a href="#FrameTransformations.Frames.@point"><code>@point</code></a> macro. <code>axes</code> is the ID or <a href="../frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> instance in which the point state-vector is  expressed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();

julia&gt; @axes ICRF 1  

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point Origin 0

julia&gt; @point Satellite 1 

julia&gt; add_point_root!(FRAMES, Origin, ICRF)

julia&gt; add_point_updatable!(FRAMES, Satellite, Origin, ICRF)

julia&gt; y = [10000., 200., 300.]

julia&gt; update_point!(FRAMES, Satellite, y, 0.1)

julia&gt; vector3(FRAMES, Origin, Satellite, ICRF, 0.1)
3-element SVector{3, Float64} with indices SOneTo(3):
 10000.0
   200.0
   300.0

julia&gt; vector3(FRAMES, Origin, Satellite, ICRF, 0.2)
ERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1

julia&gt; vector6(FRAMES, Origin, Satellite, ICRF, 0.1)
ERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2
[...]</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.update_point!"><code>update_point!</code></a>, <a href="#FrameTransformations.Frames.add_point_root!"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.add_point_ephemeris!"><code>add_point_ephemeris!</code></a>,  <a href="#FrameTransformations.Frames.add_point_dynamical!"><code>add_point_dynamical!</code></a> and <a href="#FrameTransformations.Frames.add_point_fixed!"><code>add_point_fixed!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/points.jl#L521-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.update_point!" href="#FrameTransformations.Frames.update_point!"><code>FrameTransformations.Frames.update_point!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_point!(frames, point, stv::AbstractVector, epoch::Epoch)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L622-L625">source</a></section><section><div><pre><code class="language-julia hljs">update_point!(frames::FrameSystem, point, stv::AbstractVector, time)</code></pre><p>Update the state vector of <code>point</code> at the input <code>time</code> in <code>frames</code>. The only  accepted length for the input vector <code>stv</code> are 3, 6, 9 or 12. The order is automatically  inferred from the vector length.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();
  
julia&gt; @axes ICRF 1  

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point Origin 0

julia&gt; @point Satellite 1 

julia&gt; add_point_root!(FRAMES, Origin, ICRF)

julia&gt; add_point_updatable!(FRAMES, Satellite, Origin, ICRF)

julia&gt; y = [10000., 200., 300.];

julia&gt; update_point!(FRAMES, Satellite, y, 0.1)

julia&gt; vector3(FRAMES, Origin, Satellite, ICRF, 0.1)
3-element SVector{3, StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 10000.0
   200.0
   300.0

julia&gt; vector3(FRAMES, Origin, Satellite, ICRF, 0.2)
ERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1 
[...]

julia&gt; vector6(FRAMES, Origin, Satellite, ICRF, 0.1)
ERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2 
[...] </code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_updatable!"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L631-L675">source</a></section></article><h2 id="rotation_api"><a class="docs-heading-anchor" href="#rotation_api">Rotations</a><a id="rotation_api-1"></a><a class="docs-heading-anchor-permalink" href="#rotation_api" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.Rotation" href="#FrameTransformations.Frames.Rotation"><code>FrameTransformations.Frames.Rotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rotation{S, N}</code></pre><p>A container to efficiently compute <code>S</code>-th order rotation matrices of type <code>N</code> between two  set of axes. It stores the Direction Cosine Matrix (DCM) and its time derivatives up to  the (<code>S</code>-1)-th order. Since this type is immutable, the data must be provided upon  construction and cannot be mutated later.</p><p>The rotation of state vector between two set of axes is computed with an ad-hoc overload  of the product operator. For example, a 3rd order Rotation object <code>R</code>, constructed from the  DCM <code>A</code> and its time derivatives <code>δA</code> and <code>δ²A</code> rotates a vector <code>v</code> = <code>[p, v, a]</code> as: </p><p><code>̂v = [A*p, δA*p + A*v, δ²A*p + 2δA*v + A*a]</code></p><p>A <code>Rotation</code> object <code>R</code> call always be converted to a <code>SMatrix</code> or a <code>MMatrix</code> by invoking  the proper constructor. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = angle_to_dcm(π/3, :Z)
DCM{Float64}:
  0.5       0.866025  0.0
 -0.866025  0.5       0.0
  0.0       0.0       1.0

julia&gt; R = Rotation(A);

julia&gt; SM = SMatrix(R)
3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.5       0.866025  0.0
 -0.866025  0.5       0.0
  0.0       0.0       1.0

julia&gt; MM = MMatrix(R)
3×3 MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.5       0.866025  0.0
 -0.866025  0.5       0.0
  0.0       0.0       1.0</code></pre><hr/><pre><code class="nohighlight hljs">Rotation(dcms::DCM...)</code></pre><p>Create a <code>Rotation</code> object from a Direction Cosine Matrix (DCM) and any of its time   derivatives. The rotation order is inferred from the number of inputs, while the rotation  type is obtained by promoting the DCMs types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = angle_to_dcm(π/3, :Z); 

julia&gt; δA = DCM(0.0I); 

julia&gt; δ²A = DCM(0.0I); 

julia&gt; R = Rotation(A, δA, δ²A); 

julia&gt; typeof(R) 
Rotation{3, Float64}

julia&gt; R2 = Rotation(A, B, C, DCM(0.0im*I)); 

julia&gt; typeof(R2)
Rotation{4, ComplexF64}</code></pre><hr/><pre><code class="nohighlight hljs">Rotation{S}(dcms::DCM...) where S</code></pre><p>Create a <code>Rotation</code> object of order <code>S</code>. If the number of <code>dcms</code> is smaller than <code>S</code>, the  remaining slots are filled with null DCMs, otherwise if the number of inputs is greater than  <code>S</code>, only the first <code>S</code> DCMs are used. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Usage of this constructor is not recommended as it may yield unexpected results to  unexperienced users. </p></div></div><hr/><pre><code class="nohighlight hljs">Rotation{S1}(dcms::NTuple{S2, DCM{N}}) where {S1, S2, N}</code></pre><p>Create a <code>Rotation</code> object from a tuple of Direction Cosine Matrix (DCM) and its time  derivatives. If <code>S1</code> &lt; <code>S2</code>, only the first <code>S1</code> DCMs are considered, otherwise the  remaining orders are filled with null DCMs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = angle_to_dcm(π/3, :Z);

julia&gt; B = angle_to_dcm(π/4, π/6, :XY);

julia&gt; R3 = Rotation{3}((A,B));

julia&gt; R3[1] == A
true 

julia&gt; R3[3] 
DCM{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><hr/><pre><code class="nohighlight hljs">Rotation{S}(u::UniformScaling{N}) where {S, N}
Rotation{S, N}(u::UniformScaling) where {S, N}</code></pre><p>Create an <code>S</code>-order identity <code>Rotation</code> object of type <code>N</code> with identity position rotation  and null time derivatives.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Rotation{1}(1.0I) 
Rotation{1, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],))

julia&gt; Rotation{1, Int64}(I)
Rotation{1, Int64}(([1 0 0; 0 1 0; 0 0 1],))</code></pre><hr/><pre><code class="nohighlight hljs">Rotation{S1}(rot::Rotation{S2, N}) where {S1, S2, N}
Rotation{S1, N}(R::Rotation{S2}) where {S1, S2, N}</code></pre><p>Transform a <code>Rotation</code> object of order <code>S2</code> to order <code>S1</code> and type <code>N</code>. The behaviour of  these functions depends on the values of <code>S1</code> and <code>S2</code>: </p><ul><li><code>S1</code> &lt; <code>S2</code>: Only the first <code>S1</code> components of <code>rot</code> are considered.</li><li><code>S1</code> &gt; <code>S2</code>: The missing orders are filled with null DCMs.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = angle_to_dcm(π/3, :Z);

julia&gt; B = angle_to_dcm(π/4, π/6, :XY);

julia&gt; R1 = Rotation(A, B);

julia&gt; order(R1)
2

julia&gt; R2 = Rotation{1}(R1);

julia&gt; order(R2)
1

julia&gt; R2[1] == A 
true

julia&gt; R3 = Rotation{3}(R1);

julia&gt; R3[3]
DCM{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><hr/><pre><code class="nohighlight hljs">Rotation(m::DCM{N}, ω::AbstractVector) where N</code></pre><p>Create a 2nd order <code>Rotation</code> object of type <code>N</code> to rotate between two set of axes <code>a</code> and  <code>b</code> from a Direction Cosine Matrix (DCM) and the angular velocity vector <code>ω</code> of <code>b</code> with  respect to <code>a</code>, expressed in <code>b</code></p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.rotation3"><code>rotation3</code></a>, <a href="#FrameTransformations.Frames.rotation6"><code>rotation6</code></a> and <a href="#FrameTransformations.Frames.rotation9"><code>rotation9</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/rotation.jl#L7-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.order" href="#FrameTransformations.Frames.order"><code>FrameTransformations.Frames.order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">order(R::Rotation{S}) where S</code></pre><p>Return the rotation order S.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/rotation.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv" href="#Base.inv"><code>Base.inv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inv(rot::Rotation)</code></pre><p>Compute the invese of the rotation object <code>rot</code>. The operation is efficiently performed by  taking the transpose of each rotation matrix within <code>rot</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/rotation.jl#L350-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.rotation3" href="#FrameTransformations.Frames.rotation3"><code>FrameTransformations.Frames.rotation3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation3(frame::FrameSystem, from, to, ep::Epoch)</code></pre><p>Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given epoch. </p><p>Requires a frame system of order ≥ 1.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the axes to transform from </li><li><code>to</code> – ID or instance of the axes to transform to </li><li><code>ep</code> – <code>Epoch</code> of the rotation. Its timescale must match that of the frame system. </li></ul><p><strong>Output</strong></p><p>A <a href="#FrameTransformations.Frames.Rotation"><code>Rotation</code></a> object of order 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L30-L46">source</a></section><section><div><pre><code class="language-julia hljs">rotation3(frame::FrameSystem, from, to, t::Number)</code></pre><p>Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given time <code>t</code>, expressed in seconds since  <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.rotation6" href="#FrameTransformations.Frames.rotation6"><code>FrameTransformations.Frames.rotation6</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation6(frame::FrameSystem, from, to, ep::Epoch)</code></pre><p>Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given epoch. </p><p>Requires a frame system of order ≥ 2.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the axes to transform from </li><li><code>to</code> – ID or instance of the axes to transform to </li><li><code>ep</code> – <code>Epoch</code> of the rotation. Its timescale must match that of the frame system. </li></ul><p><strong>Output</strong></p><p>A <a href="#FrameTransformations.Frames.Rotation"><code>Rotation</code></a> object of order 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L30-L46">source</a></section><section><div><pre><code class="language-julia hljs">rotation6(frame::FrameSystem, from, to, t::Number)</code></pre><p>Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given time <code>t</code>, expressed in seconds since  <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.rotation9" href="#FrameTransformations.Frames.rotation9"><code>FrameTransformations.Frames.rotation9</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation9(frame::FrameSystem, from, to, ep::Epoch)</code></pre><p>Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given epoch. </p><p>Requires a frame system of order ≥ 3.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the axes to transform from </li><li><code>to</code> – ID or instance of the axes to transform to </li><li><code>ep</code> – <code>Epoch</code> of the rotation. Its timescale must match that of the frame system. </li></ul><p><strong>Output</strong></p><p>A <a href="#FrameTransformations.Frames.Rotation"><code>Rotation</code></a> object of order 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L30-L46">source</a></section><section><div><pre><code class="language-julia hljs">rotation9(frame::FrameSystem, from, to, t::Number)</code></pre><p>Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given time <code>t</code>, expressed in seconds since  <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.rotation12" href="#FrameTransformations.Frames.rotation12"><code>FrameTransformations.Frames.rotation12</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation12(frame::FrameSystem, from, to, ep::Epoch)</code></pre><p>Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given epoch. </p><p>Requires a frame system of order ≥ 4.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the axes to transform from </li><li><code>to</code> – ID or instance of the axes to transform to </li><li><code>ep</code> – <code>Epoch</code> of the rotation. Its timescale must match that of the frame system. </li></ul><p><strong>Output</strong></p><p>A <a href="#FrameTransformations.Frames.Rotation"><code>Rotation</code></a> object of order 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L30-L46">source</a></section><section><div><pre><code class="language-julia hljs">rotation12(frame::FrameSystem, from, to, t::Number)</code></pre><p>Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given time <code>t</code>, expressed in seconds since  <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L53-L59">source</a></section></article><h2 id="Transformations"><a class="docs-heading-anchor" href="#Transformations">Transformations</a><a id="Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Transformations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.LightTime" href="#FrameTransformations.Frames.LightTime"><code>FrameTransformations.Frames.LightTime</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">LightTime</code></pre><p>The singleton instance of type <code>LightTimeCorrection</code>, used to apply light-time (planetary  aberration) corrections when computing vectors from the <code>FrameSystem</code>.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.vector3"><code>vector3</code></a> and <a href="#FrameTransformations.Frames.vector6"><code>vector6</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/lightime.jl#L16-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.PlanetaryAberration" href="#FrameTransformations.Frames.PlanetaryAberration"><code>FrameTransformations.Frames.PlanetaryAberration</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">PlanetaryAberration</code></pre><p>The singleton instance of type <code>PlanetaryAberrationCorrection</code>, used to apply one-way  light-time and stellar aberration corrections when computing vectors from the <code>FrameSystem</code>.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.vector3"><code>vector3</code></a> and <a href="#FrameTransformations.Frames.vector6"><code>vector6</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/lightime.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.vector3" href="#FrameTransformations.Frames.vector3"><code>FrameTransformations.Frames.vector3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector3(frame::FrameSystem, from, to, axes, ep::Epoch)</code></pre><p>Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch <code>ep</code>.</p><p>Requires a frame system of order ≥ 1.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the observing point</li><li><code>to</code> – ID or instance of the target point </li><li><code>axes</code> – ID or instance of the output state vector axes </li><li><code>ep</code> – <code>Epoch</code> of the observer. Its timescale must match that of the frame system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L214-L229">source</a></section><section><div><pre><code class="language-julia hljs">vector3(frame, from, to, axes, t::Number)</code></pre><p>Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time <code>t</code> expressed in  seconds since <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L242-L249">source</a></section><section><div><pre><code class="language-julia hljs">vector3(frame, from, to, axes, ep::Epoch, ltcorr, dir; &lt;keyword arguments&gt;)</code></pre><p>Compute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch <code>ep</code>,  using the aberration flag <code>ltcorr</code>, which may be any of the following <code>AbstractLightTimeCorrection</code>:</p><ul><li><p><strong>LightTimeCorrection</strong>: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. </p></li><li><p><strong>PlanetaryAberrationCorrection</strong>: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the <code>LightTimeCorrection</code> option to account for the observer velocity    with respect to the Solar System Barycenter. </p></li></ul><p>The integer argument <code>dir</code> is used to specify the correction direction, as follows:</p><ul><li><p><strong>-1</strong>: for <strong>Reception</strong>, in which photons depart from the target&#39;s location at the    light-time corrected epoch <code>ep-lt</code> and arrive at the observer&#39;s location at <code>ep</code>.</p></li><li><p><strong>+1</strong>: for <strong>Transmission</strong>, in which photons depart from the observer&#39;s location at   <code>ep</code> and arrive at the target&#39;s location at the light-time corrected epoch <code>ep+lt</code>.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>iters::Int=1</code>: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.</p></li><li><p><code>axescenter</code>: ID or instance of the center point for <code>axes</code>. This parameter is used        only when <code>axes</code> have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to <code>from</code>.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the <code>PlanetaryAberrationCorrection</code> is applied, the frame system must be at  least one order higher than that of the requested transformation.</p></div></div><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.LightTime"><code>LightTime</code></a>, <a href="#FrameTransformations.Frames.PlanetaryAberration"><code>PlanetaryAberration</code></a> and <a href="#FrameTransformations.Frames.vector6"><code>vector6</code></a>.</p><p><strong>References</strong></p><ul><li>CSPICE <a href="https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkez_c.html">Library</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L493-L536">source</a></section><section><div><pre><code class="language-julia hljs">vector3(frame, from, to, axes, t::Number, ltcorr, dir; &lt;keyword arguments&gt;)</code></pre><p>Compute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time <code>t</code>,   expressed in seconds since <code>J2000</code>, using the aberration flag <code>ltcorr</code> and  the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L550-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.vector6" href="#FrameTransformations.Frames.vector6"><code>FrameTransformations.Frames.vector6</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector6(frame::FrameSystem, from, to, axes, ep::Epoch)</code></pre><p>Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch <code>ep</code>.</p><p>Requires a frame system of order ≥ 2.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the observing point</li><li><code>to</code> – ID or instance of the target point </li><li><code>axes</code> – ID or instance of the output state vector axes </li><li><code>ep</code> – <code>Epoch</code> of the observer. Its timescale must match that of the frame system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L214-L229">source</a></section><section><div><pre><code class="language-julia hljs">vector6(frame, from, to, axes, t::Number)</code></pre><p>Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time <code>t</code> expressed in  seconds since <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L242-L249">source</a></section><section><div><pre><code class="language-julia hljs">vector6(frame, from, to, axes, ep::Epoch, ltcorr, dir; &lt;keyword arguments&gt;)</code></pre><p>Compute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch <code>ep</code>,  using the aberration flag <code>ltcorr</code>, which may be any of the following <code>AbstractLightTimeCorrection</code>:</p><ul><li><p><strong>LightTimeCorrection</strong>: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. </p></li><li><p><strong>PlanetaryAberrationCorrection</strong>: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the <code>LightTimeCorrection</code> option to account for the observer velocity    with respect to the Solar System Barycenter. </p></li></ul><p>The integer argument <code>dir</code> is used to specify the correction direction, as follows:</p><ul><li><p><strong>-1</strong>: for <strong>Reception</strong>, in which photons depart from the target&#39;s location at the    light-time corrected epoch <code>ep-lt</code> and arrive at the observer&#39;s location at <code>ep</code>.</p></li><li><p><strong>+1</strong>: for <strong>Transmission</strong>, in which photons depart from the observer&#39;s location at   <code>ep</code> and arrive at the target&#39;s location at the light-time corrected epoch <code>ep+lt</code>.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>iters::Int=1</code>: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.</p></li><li><p><code>axescenter</code>: ID or instance of the center point for <code>axes</code>. This parameter is used        only when <code>axes</code> have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to <code>from</code>.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the <code>PlanetaryAberrationCorrection</code> is applied, the frame system must be at  least one order higher than that of the requested transformation.</p></div></div><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.LightTime"><code>LightTime</code></a>, <a href="#FrameTransformations.Frames.PlanetaryAberration"><code>PlanetaryAberration</code></a> and <a href="#FrameTransformations.Frames.vector6"><code>vector6</code></a>.</p><p><strong>References</strong></p><ul><li>CSPICE <a href="https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkez_c.html">Library</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L493-L536">source</a></section><section><div><pre><code class="language-julia hljs">vector6(frame, from, to, axes, t::Number, ltcorr, dir; &lt;keyword arguments&gt;)</code></pre><p>Compute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time <code>t</code>,   expressed in seconds since <code>J2000</code>, using the aberration flag <code>ltcorr</code> and  the direction <code>dir</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L550-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.vector9" href="#FrameTransformations.Frames.vector9"><code>FrameTransformations.Frames.vector9</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector9(frame::FrameSystem, from, to, axes, ep::Epoch)</code></pre><p>Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch <code>ep</code>.</p><p>Requires a frame system of order ≥ 3.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the observing point</li><li><code>to</code> – ID or instance of the target point </li><li><code>axes</code> – ID or instance of the output state vector axes </li><li><code>ep</code> – <code>Epoch</code> of the observer. Its timescale must match that of the frame system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L214-L229">source</a></section><section><div><pre><code class="language-julia hljs">vector9(frame, from, to, axes, t::Number)</code></pre><p>Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time <code>t</code> expressed in  seconds since <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L242-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="FrameTransformations.Frames.vector12" href="#FrameTransformations.Frames.vector12"><code>FrameTransformations.Frames.vector12</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector12(frame::FrameSystem, from, to, axes, ep::Epoch)</code></pre><p>Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch <code>ep</code>.</p><p>Requires a frame system of order ≥ 4.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the observing point</li><li><code>to</code> – ID or instance of the target point </li><li><code>axes</code> – ID or instance of the output state vector axes </li><li><code>ep</code> – <code>Epoch</code> of the observer. Its timescale must match that of the frame system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L214-L229">source</a></section><section><div><pre><code class="language-julia hljs">vector12(frame, from, to, axes, t::Number)</code></pre><p>Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time <code>t</code> expressed in  seconds since <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/1e325d2c85fb579c3fb851fabc868524ca0a0bc1/src/Frames/transform.jl#L242-L249">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../benchmarks/">« Benchmarks</a><a class="docs-footer-nextpage" href="../frames_lapi/">Low-level API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 4 January 2024 16:35">Thursday 4 January 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
