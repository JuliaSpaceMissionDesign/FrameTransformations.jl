<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>03 - Axes · FrameTransformations.jl</title><meta name="title" content="03 - Axes · FrameTransformations.jl"/><meta property="og:title" content="03 - Axes · FrameTransformations.jl"/><meta property="twitter:title" content="03 - Axes · FrameTransformations.jl"/><meta name="description" content="Documentation for FrameTransformations.jl."/><meta property="og:description" content="Documentation for FrameTransformations.jl."/><meta property="twitter:description" content="Documentation for FrameTransformations.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="FrameTransformations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">FrameTransformations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../t00_frames/">01 - Frame System</a></li><li><a class="tocitem" href="../t01_rotation/">02 - Rotation</a></li><li class="is-active"><a class="tocitem" href>03 - Axes</a><ul class="internal"><li><a class="tocitem" href="#Graph-Initialisation"><span>Graph Initialisation</span></a></li><li><a class="tocitem" href="#ine_axes"><span>Inertial Axes</span></a></li><li><a class="tocitem" href="#fox_axes"><span>Fixed-offset Axes</span></a></li><li><a class="tocitem" href="#rot_axes"><span>Rotating Axes</span></a></li><li><a class="tocitem" href="#Ephemeris-Axes"><span>Ephemeris Axes</span></a></li></ul></li><li><a class="tocitem" href="../t03_points/">04 - Points</a></li></ul></li><li><a class="tocitem" href="../../../benchmarks/">Benchmarks</a></li><li><span class="tocitem">API</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Public API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../API/frames_api/">Frames</a></li><li><a class="tocitem" href="../../../API/axes_api/">Axes</a></li><li><a class="tocitem" href="../../../API/point_api/">Points</a></li><li><a class="tocitem" href="../../../API/dir_api/">Directions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>03 - Axes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>03 - Axes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/main/docs/src/Tutorials/t02_axes.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial_01_axes"><a class="docs-heading-anchor" href="#tutorial_01_axes">Axes</a><a id="tutorial_01_axes-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial_01_axes" title="Permalink"></a></h1><p><em>This example was generated on 2024-06-03T17:28:23.516.</em></p><p>To compute relative orientations, <code>FrameTransformations</code> provides the capability to define custom and standard reference axes (e.g., the ITRF) and arbitrarily connect them through the <a href="../../../API/frames_api/#FrameTransformations.FrameSystem"><code>FrameSystem</code></a> In turn, this allows the computation of the relative orientation and its derivatives (up to order 3) between any two registered axes.</p><p>At the time being, the following types of axes are supported:</p><ul><li><strong>Inertial axes</strong>: these are the only ones which can be used as root axes to initialise the axes graph.</li><li><strong>Fixed offset axes</strong>: they have a constant orientation with respect to their parent axes.</li><li><strong>Rotating axes</strong>: the orientation of these axes depends only on time and is computed t through the custom functions provided by the user.</li><li><strong>Ephemeris axes</strong>: these are constructed by extracting the Euler rotation angles and their derivatives from the binary PCK kernels that are loaded within the <a href="../../../API/frames_api/#FrameTransformations.FrameSystem"><code>FrameSystem</code></a>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This package provides a dedicated function to register each type of supported axes. Additionally, higher-level functions to automatically register standard astronomical reference axes are also provided, e.g., <a href="../../../API/axes_api/#FrameTransformations.add_axes_ecl2000!"><code>add_axes_ecl2000!</code></a>.</p></div></div><h2 id="Graph-Initialisation"><a class="docs-heading-anchor" href="#Graph-Initialisation">Graph Initialisation</a><a id="Graph-Initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Initialisation" title="Permalink"></a></h2><p>In this section we will display how to create a frame system to compute generic axes rotation. First of all, we need to load both this package and an ephemeris reader. The latter will be used to compute the orientation of the Moon&#39;s Principal Axes (PA) 440,  whose Euler angles are defined in binary PCK kernels and to retrieve the positions of the planets. In this example, <a href="https://github.com/JuliaSpaceMissionDesign/Ephemerides.jl">Ephemerides.jl</a> package and download the kernels from NAIF&#39;s website.</p><pre><code class="language-julia hljs">using FrameTransformations
using Ephemerides

url_pck = &quot;https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc&quot;;
url_spk = &quot;https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp&quot;;

const EPH = EphemerisProvider([download(url_spk), download(url_pck)])
const F = FrameSystem{3, Float64}()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FrameSystem{3, Float64, Tempo.BarycentricDynamicalTime, 9} with 0 points, 0 axes and 0 directions
</code></pre><p>To initialise the axes graph, a set of root axes must be initially registered. These will serve as the uppermost node of the graph and have no parents, meaning their orientation is not specified. Only inertial axes can be used as root axes of the <a href="../../../API/frames_api/#FrameTransformations.FrameSystem"><code>FrameSystem</code></a>.</p><p>In this example, we will use the <code>ICRF</code> as our base root inertial axes.</p><pre><code class="language-julia hljs">add_axes_root!(F, :ICRF, AXESID_ICRF)</code></pre><p>Once a set of root axes has been registered, any other type of axes can be added to the system.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For standard applications, it is good practice that the axes&#39;s IDs are as in agreement with NAIF&#39;s numbering system. A list of IDs for the most common axes is provided in this package.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points.</p></div></div><p>Inertial axes are those that are fixed with respect to the star background. They are the only ones that can be used as root axes in the frame system but can also be defined through a relative orientation with respect to another set of inertial axis.</p><h2 id="ine_axes"><a class="docs-heading-anchor" href="#ine_axes">Inertial Axes</a><a id="ine_axes-1"></a><a class="docs-heading-anchor-permalink" href="#ine_axes" title="Permalink"></a></h2><p>In this example, we register the <code>GCRF</code> as a set of inertial axes with respect to the <code>ICRF</code>. We assume that the two frames are equivalent, thus:</p><pre><code class="language-julia hljs">using ReferenceFrameRotations
using LinearAlgebra

fun(t) = DCM(1.0I)
add_axes_inertial!(F, :GCRF, AXESID_GCRF, AXESID_ICRF, fun)

R = rotation6(F, AXESID_ICRF, AXESID_GCRF, 1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rotation{2, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]))</code></pre><pre><code class="language-julia hljs">R[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DCM{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre><pre><code class="language-julia hljs">R[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DCM{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>Since it is an inertial frame, the time derivative of the rotation is null.</p><h2 id="fox_axes"><a class="docs-heading-anchor" href="#fox_axes">Fixed-offset Axes</a><a id="fox_axes-1"></a><a class="docs-heading-anchor-permalink" href="#fox_axes" title="Permalink"></a></h2><p>Fixed-offset axes have a constant orientation with respect to their parent axes in time. We previously saw that inertial axes can also be used to define axes with a fixed orientation  with respect to their parents. However, while inertial axes do not rotate with respect to the star background, fixed offset axes are only constant with respect to their parent axes, but might be rotating with respect to some other inertial axes.</p><p>In this example, we register <code>FOX</code> as a set of axes with a fixed rotation of <code>π/4</code> around the Z-axis with respect to the <code>ICRF</code>.</p><pre><code class="language-julia hljs">rot = angle_to_dcm(π/4, :Z)

add_axes_fixedoffset!(F, :FOX, 2, AXESID_ICRF, rot)</code></pre><p>The state rotation matrix can then be obtained as:</p><pre><code class="language-julia hljs">R = rotation6(F, 1, 2, 86400)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rotation{2, Float64}(([0.7071067811865476 0.7071067811865475 0.0; -0.7071067811865475 0.7071067811865476 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]))</code></pre><pre><code class="language-julia hljs">R[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DCM{Float64}:
  0.707107  0.707107  0.0
 -0.707107  0.707107  0.0
  0.0       0.0       1.0</code></pre><pre><code class="language-julia hljs">R[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DCM{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>Since <code>FOX</code> has a constant orientation with respect to the <code>ICRF</code>, the time derivative of the rotation matrix <code>R[2]</code> is, in fact, null. For further information see the <a href="../../../API/axes_api/#FrameTransformations.add_axes_fixedoffset!"><code>add_axes_fixedoffset!</code></a> documentation.</p><h2 id="rot_axes"><a class="docs-heading-anchor" href="#rot_axes">Rotating Axes</a><a id="rot_axes-1"></a><a class="docs-heading-anchor-permalink" href="#rot_axes" title="Permalink"></a></h2><p>Rotating axes are generic, time-dependant, non-inertial axes. In order to register this kind of axes, a function (and optionally its derivatives) that expresses the relative orientation of this axes must be defined. This function shall return a Direction Cosine Matrix (DCM), available from <a href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl">ReferenceFrameRotations.jl</a>.</p><pre><code class="language-julia hljs">fun(t) = angle_to_dcm(-t, :Z)

add_axes_rotating!(F, :ROX, 3, AXESID_ICRF, fun)</code></pre><p>If we now compute the orientation between the <code>FOX</code> and <code>ROX</code> at <code>π/4</code> we obtain an identity rotation, since the orientation of <code>ROX</code> is directed in the opposite direction of <code>FOX</code>.</p><pre><code class="language-julia hljs">R = rotation6(F, 2, 3, π/4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rotation{2, Float64}(([2.220446049250313e-16 -1.0 0.0; 1.0 2.220446049250313e-16 0.0; 0.0 0.0 1.0], [-1.0 -2.220446049250313e-16 0.0; 2.220446049250313e-16 -1.0 0.0; 0.0 0.0 0.0]))</code></pre><pre><code class="language-julia hljs">R[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DCM{Float64}:
 2.22045e-16  -1.0          0.0
 1.0           2.22045e-16  0.0
 0.0           0.0          1.0</code></pre><p>Notice that, although we only provided a function that expresses the relative orientation, the frame system has automatically computed its time-derivative via Automatic Differentiation (AD) of <code>fun</code>.</p><pre><code class="language-julia hljs">R2 = rotation6(F, 1, 3, π/4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rotation{2, Float64}(([0.7071067811865476 -0.7071067811865475 0.0; 0.7071067811865475 0.7071067811865476 0.0; 0.0 0.0 1.0], [-0.7071067811865475 -0.7071067811865476 0.0; 0.7071067811865476 -0.7071067811865475 0.0; 0.0 0.0 0.0]))</code></pre><pre><code class="language-julia hljs">R2[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DCM{Float64}:
 -0.707107  -0.707107  0.0
  0.707107  -0.707107  0.0
  0.0        0.0       0.0</code></pre><p>This becomes particularly useful for rapid prototyping or when the manual differentiation requires a lot of time. The functions for higher-order derivatives, must return the original DCM and its derivatives up to their orders. For example:</p><pre><code class="language-julia hljs">using JSMDUtils.Math

fun(t) = angle_to_dcm(-t, :Z)
dfun(t) = (angle_to_dcm(-t, :Z), Math.angle_to_δdcm([-t, -1], :Z))

add_axes_rotating!(F, :ROX2, 4, AXESID_ICRF, fun, dfun)

R2 = rotation6(F, 1, 3, π/4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rotation{2, Float64}(([0.7071067811865476 -0.7071067811865475 0.0; 0.7071067811865475 0.7071067811865476 0.0; 0.0 0.0 1.0], [-0.7071067811865475 -0.7071067811865476 0.0; 0.7071067811865476 -0.7071067811865475 0.0; 0.0 0.0 0.0]))</code></pre><pre><code class="language-julia hljs">R2[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DCM{Float64}:
 -0.707107  -0.707107  0.0
  0.707107  -0.707107  0.0
  0.0        0.0       0.0</code></pre><p>We can see the results are in agreement with the previous example. For more details, see <a href="../../../API/axes_api/#FrameTransformations.add_axes_rotating!"><code>add_axes_rotating!</code></a> documentation.</p><h2 id="Ephemeris-Axes"><a class="docs-heading-anchor" href="#Ephemeris-Axes">Ephemeris Axes</a><a id="Ephemeris-Axes-1"></a><a class="docs-heading-anchor-permalink" href="#Ephemeris-Axes" title="Permalink"></a></h2><p>Ephemeris axes a are a type of time-dependent axes which are build by means of Euler angles contained within a binary PCK ephemeris kernel. For example, in practice these are used to express the orientation of high-accuracy Lunar body-fixed frames (i.e., the Principal Axes) or the Earth&#39;s ITRF.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To properly compute the orientation of these axes, the ephemeris provider used must contain the necessary PCK kernels. Additionally, in this case the ID of the registered axes must match the ID contained in the PCK kernels.</p></div></div><p>In this example, the ephemeris provider <code>EPH</code> has loaded the DE421 PCK kernel containing the orientation of the Moon&#39;s Principal Axes (PA421). NAIF&#39;s system has assigned to such set of axes the ID <code>31006</code>. If a different ID was assigned to the <code>MoonPA</code>, the function would have thrown an error.</p><p>The function also requires the user to specify the rotation sequence to convert the Euler angles to a proper rotation matrix.</p><pre><code class="language-julia hljs">add_axes_ephemeris!(F, EPH, :MOONPA, 31006, :ZXZ)

R = rotation6(F, 1, 31006, 86400.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rotation{2, Float64}(([0.6219855961037569 0.7077415949385507 0.33501604891898906; -0.7827096425059984 0.5741656785808802 0.24020697131409327; -0.022350252069861617 -0.4116255681242284 0.911078952615425], [-2.0835792981059603e-6 1.5281546248856286e-6 6.400222345301864e-7; -1.6557195262995373e-6 -1.8840097087356063e-6 -8.917889621565607e-7; -3.880601321351557e-10 -4.740262874274574e-10 -2.236848750095691e-10]))</code></pre><pre><code class="language-julia hljs">R[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DCM{Float64}:
  0.621986    0.707742  0.335016
 -0.78271     0.574166  0.240207
 -0.0223503  -0.411626  0.911079</code></pre><pre><code class="language-julia hljs">R[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DCM{Float64}:
 -2.08358e-6   1.52815e-6    6.40022e-7
 -1.65572e-6  -1.88401e-6   -8.91789e-7
 -3.8806e-10  -4.74026e-10  -2.23685e-10</code></pre><p>For further information see the <a href="../../../API/axes_api/#FrameTransformations.add_axes_ephemeris!"><code>add_axes_ephemeris!</code></a> documentation.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t01_rotation/">« 02 - Rotation</a><a class="docs-footer-nextpage" href="../t03_points/">04 - Points »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 3 June 2024 17:29">Monday 3 June 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
