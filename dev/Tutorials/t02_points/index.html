<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>03 - Points · FrameTransformations.jl</title><meta name="title" content="03 - Points · FrameTransformations.jl"/><meta property="og:title" content="03 - Points · FrameTransformations.jl"/><meta property="twitter:title" content="03 - Points · FrameTransformations.jl"/><meta name="description" content="Documentation for FrameTransformations.jl."/><meta property="og:description" content="Documentation for FrameTransformations.jl."/><meta property="twitter:description" content="Documentation for FrameTransformations.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FrameTransformations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FrameTransformations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../t00_frames/">01 - Frame System</a></li><li><a class="tocitem" href="../t01_axes/">02 - Axes</a></li><li class="is-active"><a class="tocitem" href>03 - Points</a><ul class="internal"><li><a class="tocitem" href="#Graph-Initialisation"><span>Graph Initialisation</span></a></li><li><a class="tocitem" href="#Fixed-Points"><span>Fixed Points</span></a></li><li><a class="tocitem" href="#Dynamical-Points"><span>Dynamical Points</span></a></li><li><a class="tocitem" href="#updatable_points"><span>Updatable Points</span></a></li><li><a class="tocitem" href="#Ephemeris-Points"><span>Ephemeris Points</span></a></li></ul></li><li><a class="tocitem" href="../t03_cr3bp/">04 - Use Case: CR3BP</a></li><li><a class="tocitem" href="../t04_hifi/">05 - Use Case: High Fidelity</a></li><li><a class="tocitem" href="../t05_multithread/">06 - Multithreading</a></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><span class="tocitem">Modules</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Frames</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Modules/frames_api/">Public API</a></li><li><a class="tocitem" href="../../Modules/frames_lapi/">Low-level API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Orient</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Modules/orient_api/">Public API</a></li><li><a class="tocitem" href="../../Modules/orient_lapi/">Low-level API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Utils</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Modules/utils_api/">Public API</a></li><li><a class="tocitem" href="../../Modules/utils_lapi/">Low-level API</a></li></ul></li></ul></li><li><a class="tocitem" href="../../roadmap/">Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>03 - Points</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>03 - Points</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/main/docs/src/Tutorials/t02_points.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial_02_points"><a class="docs-heading-anchor" href="#tutorial_02_points">Points Creation and Translations</a><a id="tutorial_02_points-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial_02_points" title="Permalink"></a></h1><p>Similarly to <a href="../t01_axes/#tutorial_01_axes">axes</a>, <code>FrameTransformations</code> also provides the capability to define custom and standard reference points (e.g., the Solar System Barycenter) and arbitrarily connect them through the <a href="../../Modules/frames_api/#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> In turn, this allows the computation of the relative position and its derivatives (up to order 3) between any two registered points and express it in any known set of axes. </p><p>At the time being, the following types of points are supported:</p><ul><li><strong>Root point</strong>: it is the root of the point graph.</li><li><strong>Fixed points</strong>: are those whose positions have a constant offset with respect their parent point in a given set of axes.</li><li><strong>Dynamical points</strong>: the position of these points depends only on time and is computed through custom user-defined functions.</li><li><strong>Ephemeris points</strong>: are those whose state-vector is retrieved from binary SPK kernels (e.g., DE440) that are loaded within the <a href="../../Modules/frames_api/#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a>.</li><li><strong>Updatable points</strong>: differently from all the other classes, the state vector for updatable points must be manually updated at a given epoch before it can be used in any transformation at the same epoch.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This package provides a dedicated function to register each type of supported points.</p></div></div><h2 id="Graph-Initialisation"><a class="docs-heading-anchor" href="#Graph-Initialisation">Graph Initialisation</a><a id="Graph-Initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Initialisation" title="Permalink"></a></h2><p>In this section we will display how to create a frame system to compute generic points transformation. Differently from the axes graph, each register point is also associated to a set of axes. Hence, this tutorial assumes the reader to already be familiar with the different types of axes and their definitions. First of all, we need to load both this package and an ephemeris reader. The latter will be used to retrieve the positions of the planets from the binary SPK kernels. In this example, we will use our own <a href="https://github.com/JuliaSpaceMissionDesign/Ephemerides.jl">Ephemerides.jl</a> package and download the kernels from NAIF&#39;s website.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; G = FrameSystem{2, Float64}()</code><code class="nohighlight hljs ansi" style="display:block;">FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(
  eph: JSMDUtils.NullEphemerisProvider(),
  points: EMPTY
  axes: EMPTY
)</code></pre><p>To initialise the point graph, we first need to define a root point. This, in turn, must be associated to an arbitrary set of axes. Therefore, we begin by definining a generic <code>SatelliteFrame</code>, here considered as inertial, and then register a root point, called <code>SpacecraftCenter</code> in our graph. Similarly, to axes, the <a href="../../Modules/frames_api/#FrameTransformations.Frames.@point"><code>@point</code></a> macro is used to define an acronym, an ID and a name of each point that we wish to register in the system. If a name is not provided, a default one is used. </p><p>A root point can be registered using the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_point_root!"><code>add_point_root!</code></a> function: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes SATF 1 SatelliteFrame</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_inertial!(G, SATF)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point SC -10000 SpacecraftCenter</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_root!(G, SC, SATF)</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For standard applications, it is good practice that the points&#39;s IDs are as in agreement with NAIF&#39;s numbering system. This becomes mandatory to properly read JPL&#39;s SPK kernels.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the point are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning. </p></div></div><p>We can now see that our axes and point graphs are populating themselves:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; G</code><code class="nohighlight hljs ansi" style="display:block;">FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(
  eph: JSMDUtils.NullEphemerisProvider(),
  points:
	 SC

  axes:
	SATF

)</code></pre><h2 id="Fixed-Points"><a class="docs-heading-anchor" href="#Fixed-Points">Fixed Points</a><a id="Fixed-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-Points" title="Permalink"></a></h2><p>Fixed points have a constant relative position vector with respect to their parent points in a given set of axes. Similarly to fixed-offset axes, these points are fixed w.r.t. their parents but might be moving with respect to others. </p><p>In this example, we use the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_point_fixed!"><code>add_point_fixed!</code></a> function to register the location of an antenna and two solar panels, which are generally fixed in the satellite body-fixed frame. To do so, we define a position offset in the form of a 3-elements vector with respect to the <code>SpacecraftCenter</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point SACL -10101 SolarArrayCenterLeft</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point SACR -10102 SolarArrayCenterRight</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point Antenna -10001</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sa_offset_left = [1.0, 0.0, 0.0]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 0.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sa_offset_right = [-1.0, 0.0, 0.0]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 -1.0
  0.0
  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; an_offset = [0.0, 0.0, -1.0]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
  0.0
 -1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_fixed!(G, SACL, SC, SATF, sa_offset_left)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_fixed!(G, SACR, SC, SATF, sa_offset_right)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_fixed!(G, Antenna, SC, SATF, an_offset)</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>As a result the graph is now populated with the new points and we can finally compute their relative positions and velocities with the proper transformation functions: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; vector3(G, SACL, SC, SATF, 0.0)</code><code class="nohighlight hljs ansi" style="display:block;">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 -1.0
 -0.0
 -0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vector6(G, Antenna, SACR, SATF, 10.0)</code><code class="nohighlight hljs ansi" style="display:block;">6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):
 -1.0
 -0.0
  1.0
 -0.0
 -0.0
 -0.0</code></pre><p>As expected, since these points are fixed, the relative velocity vector is null.</p><h2 id="Dynamical-Points"><a class="docs-heading-anchor" href="#Dynamical-Points">Dynamical Points</a><a id="Dynamical-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamical-Points" title="Permalink"></a></h2><p>Dynamical points are generic time-dependent points whose position vector (and optionally its derivatives) are only function of time. However, differently from ephemeris points, their position is computed through  user-defined functions.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point TimeDependantAppendage -10003</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fun(t) = [cos(t), sin(t), 0]</code><code class="nohighlight hljs ansi" style="display:block;">fun (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_dynamical!(G, TimeDependantAppendage, SACL, SATF, fun)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vector6(G, TimeDependantAppendage, SC, SATF, π/3)</code><code class="nohighlight hljs ansi" style="display:block;">6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):
 -1.5
 -0.8660254037844386
 -0.0
  0.8660254037844386
 -0.5000000000000001
 -0.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To avoid allocations, <code>fun</code> should return a static array.</p></div></div><p>Similarly to rotating-axes, if the user only provides the function to compute the relative position, the remaining derivatives are automatically retrievied via automatic differentiation of <code>fun</code>. On the other hand, if those functions are specified, they must return a single vector that stacks all the components. For instance, for the second order derivative of <code>fun</code>, the function should return a 9-elements vector containing the relative position, velocity and acceleration. For example: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point TimeDependantAppendage2 -10004</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fun(t) = [cos(t), sin(t), 0]</code><code class="nohighlight hljs ansi" style="display:block;">fun (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dfun(t) = [cos(t), sin(t), 0, -sin(t), cos(t), 0]</code><code class="nohighlight hljs ansi" style="display:block;">dfun (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_dynamical!(G, TimeDependantAppendage2, SACL, SATF, fun, dfun)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vector6(G, TimeDependantAppendage2, SC, SATF, π/3)</code><code class="nohighlight hljs ansi" style="display:block;">6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):
 -1.5
 -0.8660254037844386
 -0.0
  0.8660254037844386
 -0.5000000000000001
 -0.0</code></pre><p>We can again see that the results are in agreement with the previous example. For more details, consult the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_point_dynamical!"><code>add_point_dynamical!</code></a> documentation.</p><h2 id="updatable_points"><a class="docs-heading-anchor" href="#updatable_points">Updatable Points</a><a id="updatable_points-1"></a><a class="docs-heading-anchor-permalink" href="#updatable_points" title="Permalink"></a></h2><p>Updatable points are a class of point whose states at a given epoch must be manually updated  before any other computation at the same epoch can occur. They can be inserted in the  computational graphs as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point UA -10002 UpdatableAppendage</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_updatable!(G, UA, SC, SATF)</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>If we now call a transformation involving this point, an error will be thrown because we have  not registered any state for this point. To do so, we use the <a href="../../Modules/frames_api/#FrameTransformations.Frames.update_point!"><code>update_point!</code></a> function and then  evaluate the relative position: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ua_pos = [0.0, -1.0, 0.0]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
  0.0
 -1.0
  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; update_point!(G, UA, ua_pos, 0.0)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vector3(G, Antenna, UA, SATF, 0.0)</code><code class="nohighlight hljs ansi" style="display:block;">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 -0.0
 -1.0
  1.0</code></pre><p>Note that in the previous example, only the position has been updated but the current frame system is of order two! Therefore, in this case, calling <a href="../../Modules/frames_api/#FrameTransformations.Frames.vector6"><code>vector6</code></a> will give an error since  the computational graph is order-sentitive.</p><p>To correct that behaviour, also the higher order shall be updated:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; update_point!(G, UA, [1.0, -1.0, 0.0, 0.0, 0.0, 0.0], .0)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vector6(G, Antenna, UA, SATF, 0.0)</code><code class="nohighlight hljs ansi" style="display:block;">6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):
  1.0
 -1.0
  1.0
 -0.0
 -0.0
 -0.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Updatable points do not store any history of the updated states. Meaning that each time  a state is updated at a different epoch, the information of the older epochs is completely lost.</p></div></div><h2 id="Ephemeris-Points"><a class="docs-heading-anchor" href="#Ephemeris-Points">Ephemeris Points</a><a id="Ephemeris-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Ephemeris-Points" title="Permalink"></a></h2><p>Ephemeris points are a type of time-dependent points whose position and higher-order derivatives are retrieved from a binary SPK ephemeris kernel. However, differently from all other points, in this case the set of axes is automatically inferred from those contained in the ephemeris kernels. In case such set is not yet registered in the frame system, an error will be thrown. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To properly compute the position of these points, the <a href="../../Modules/frames_api/#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object must contain an ephemeris provider that has loaded the necessary kernels. Additionally, in this case the ID of the registered points must match the ID contained in the SPK kernels. </p></div></div><p>In this example, we define a new frame system <code>F</code> and give it an ephemeris provider that has loaded the DE421 SPK kernel, containing the position of the major planets and/or their barycenters of the Solar System.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Ephemerides, Downloads</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spk = &quot;https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eph = EphemerisProvider(Downloads.download(spk))</code><code class="nohighlight hljs ansi" style="display:block;">1-kernel EphemerisProvider:
 &quot;/tmp/jl_qLyZePaVEx&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; F = FrameSystem{2, Float64}(eph)</code><code class="nohighlight hljs ansi" style="display:block;">FrameSystem{2, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(
  eph: 1-kernel EphemerisProvider,
  points: EMPTY
  axes: EMPTY
)</code></pre><p>We now register some points that are stored in the kernels using the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_point_ephemeris!"><code>add_point_ephemeris!</code></a> function: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes ICRF 1</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point SSB 0</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point Sun 10</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point EMB 3</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point Earth 399</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_inertial!(F, ICRF)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_root!(F, SSB, ICRF)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_ephemeris!(F, Sun, SSB)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_ephemeris!(F, EMB)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_ephemeris!(F, Earth)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; F</code><code class="nohighlight hljs ansi" style="display:block;">FrameSystem{2, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(
  eph: 1-kernel EphemerisProvider,
  points:
	 SSB
	  ├── Sun
	  ├── EMB
	   ├── Earth

  axes:
	ICRF

)</code></pre><p>Notice that this function does not necessarily requires the parent point. Indeed, if no point is specified, the parent is automatically set to those contained in the descriptors of the ephemeris kernels. For instance, in the DE421, the Earth-Moon Barycenter (EMB) is defined with respect to the SSB, which the frame system automatically uses as parent for the EMB. Similarly, the EMB is the default parent point for the Earth.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is always recommended to use as parent of ephemeris points, the point with respect to which its ephemeris data is written in the binary kernels. This becomes mandatory if <a href="https://github.com/JuliaSpaceMissionDesign/Ephemerides.jl"><code>Ephemerides.jl</code></a> is used as an ephemeris provider.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If a parent point is not specified and the point in the kernels has not yet been registered, an error is thrown. </p></div></div><p>Finally, we can retrieve the transformation data as usual: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; vector6(F, EMB, SSB, ICRF, 1000.0)</code><code class="nohighlight hljs ansi" style="display:block;">6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):
  2.759995209892622e7
 -1.323531471583657e8
 -5.741553718779148e7
 29.776022371329166
  5.043381865003682
  2.1867059592615563</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vector3(F, Earth, SSB, ICRF, 0.0)</code><code class="nohighlight hljs ansi" style="display:block;">3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
  2.756663231104537e7
 -1.3236142853828153e8
 -5.7418647383661106e7</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t01_axes/">« 02 - Axes</a><a class="docs-footer-nextpage" href="../t03_cr3bp/">04 - Use Case: CR3BP »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Friday 29 September 2023 16:43">Friday 29 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
