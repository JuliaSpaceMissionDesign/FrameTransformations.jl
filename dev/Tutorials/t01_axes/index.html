<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>02 - Axes · FrameTransformations.jl</title><meta name="title" content="02 - Axes · FrameTransformations.jl"/><meta property="og:title" content="02 - Axes · FrameTransformations.jl"/><meta property="twitter:title" content="02 - Axes · FrameTransformations.jl"/><meta name="description" content="Documentation for FrameTransformations.jl."/><meta property="og:description" content="Documentation for FrameTransformations.jl."/><meta property="twitter:description" content="Documentation for FrameTransformations.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FrameTransformations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FrameTransformations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../t00_frames/">01 - Frame System</a></li><li class="is-active"><a class="tocitem" href>02 - Axes</a><ul class="internal"><li><a class="tocitem" href="#Rotations"><span>Rotations</span></a></li><li><a class="tocitem" href="#Graph-Initialisation"><span>Graph Initialisation</span></a></li><li><a class="tocitem" href="#Inertial-Axes"><span>Inertial Axes</span></a></li><li><a class="tocitem" href="#Fixed-offset-Axes"><span>Fixed-offset Axes</span></a></li><li><a class="tocitem" href="#rot_axes"><span>Rotating Axes</span></a></li><li><a class="tocitem" href="#Projected-Axes"><span>Projected Axes</span></a></li><li><a class="tocitem" href="#Computable-Axes"><span>Computable Axes</span></a></li><li><a class="tocitem" href="#Ephemeris-Axes"><span>Ephemeris Axes</span></a></li></ul></li><li><a class="tocitem" href="../t02_points/">03 - Points</a></li><li><a class="tocitem" href="../t03_cr3bp/">04 - Use Case: CR3BP</a></li><li><a class="tocitem" href="../t04_hifi/">05 - Use Case: High Fidelity</a></li><li><a class="tocitem" href="../t05_multithread/">06 - Multithreading</a></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><span class="tocitem">Modules</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Frames</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Modules/frames_api/">Public API</a></li><li><a class="tocitem" href="../../Modules/frames_lapi/">Low-level API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Orient</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Modules/orient_api/">Public API</a></li><li><a class="tocitem" href="../../Modules/orient_lapi/">Low-level API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Utils</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Modules/utils_api/">Public API</a></li><li><a class="tocitem" href="../../Modules/utils_lapi/">Low-level API</a></li></ul></li></ul></li><li><a class="tocitem" href="../../roadmap/">Roadmap</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>02 - Axes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>02 - Axes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/main/docs/src/Tutorials/t01_axes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial_01_axes"><a class="docs-heading-anchor" href="#tutorial_01_axes">Axes Creation and Rotations</a><a id="tutorial_01_axes-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial_01_axes" title="Permalink"></a></h1><p>To compute relative orientations, <code>FrameTransformations</code> provides the capability to define custom and standard reference axes (e.g., the ITRF) and arbitrarily connect them through the <a href="../../Modules/frames_api/#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> In turn, this allows the computation of the relative orientation and its derivatives (up to order 3) between any two registered axes. </p><p>At the time being, the following types of axes are supported:</p><ul><li><strong>Inertial axes</strong>: these are the only ones which can be used as root axes to initialise the axes graph. </li><li><strong>Fixed offset axes</strong>: they have a constant orientation with respect to their parent axes.</li><li><strong>Rotating axes</strong>: the orientation of these axes depends only on time and is computed through the custom functions provided by the user</li><li><strong>Computable axes</strong>: they are computed through two vectors that are defined within the frame system itself. Computable axes are the equivalent of SPICE&#39;s parameterized two-vector frames.</li><li><strong>Projected axes</strong>: the orientation of these axes depends only on time and is computed through the custom functions provided by the user. Projected axes are similar to rotating axis, except that all the positions, velocity, etc ... are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null, despite the rotation depends on time).</li><li><strong>Ephemeris axes</strong>: these are constructed by extracting the Euler rotation angles and their derivatives from the binary PCK kernels that are loaded within the <a href="../../Modules/frames_api/#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This package provides a dedicated function to register each type of supported axes. Additionally, higher-level functions to automatically register standard astronomical reference axes are also provided, e.g., <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_axes_eclipj2000!"><code>add_axes_eclipj2000!</code></a>.</p></div></div><h2 id="Rotations"><a class="docs-heading-anchor" href="#Rotations">Rotations</a><a id="Rotations-1"></a><a class="docs-heading-anchor-permalink" href="#Rotations" title="Permalink"></a></h2><p>Before diving into the creation of the axes graph, it is worth highlighting that transformations that express the relative orientation or its time-derivatives between two generic set of axes are represented by a <a href="../../Modules/frames_api/#FrameTransformations.Frames.Rotation"><code>Rotation</code></a> object, which stores a Direction Cosine Matrix (DCM) and its derivatives. This package leverages the already available <a href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl">ReferenceFrameRotations.jl</a> to define the DCM objects. </p><p>A time-fixed rotation between two axes and its derivative can then be expressed as follows: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ReferenceFrameRotations</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dcm  = angle_to_dcm(π/3, :Z)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  0.5       0.866025  0.0
 -0.866025  0.5       0.0
  0.0       0.0       1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; δdcm = DCM(0I)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Int64}:
 0  0  0
 0  0  0
 0  0  0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = Rotation(dcm, δdcm)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([0.5000000000000001 0.8660254037844386 0.0; -0.8660254037844386 0.5000000000000001 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R[1]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  0.5       0.866025  0.0
 -0.866025  0.5       0.0
  0.0       0.0       1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R[2]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>A rotation object is returned by all the rotation functions that are applied to the frame system. It provide overloads to the basic algebraic operations so that multiplication and inversions can be efficiently computed leveraging the properties of rotation matrixes. For example, to rotate a generic vector <code>v</code>, we can simply do: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = [1., -6., 3., 0., 5., 0]</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Float64}:
  1.0
 -6.0
  3.0
  0.0
  5.0
  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R*v</code><code class="nohighlight hljs ansi" style="display:block;">6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):
 -4.696152422706632
 -3.8660254037844393
  3.0
  4.330127018922193
  2.5000000000000004
  0.0</code></pre><p>The inverse can instead be taken as: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; inv(R)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([0.5000000000000001 -0.8660254037844386 0.0; 0.8660254037844386 0.5000000000000001 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]))</code></pre><p>See the <a href="../../Modules/frames_api/#rotation_api">Rotation API</a> for more information on this object.</p><h2 id="Graph-Initialisation"><a class="docs-heading-anchor" href="#Graph-Initialisation">Graph Initialisation</a><a id="Graph-Initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Initialisation" title="Permalink"></a></h2><p>In this section we will display how to create a frame system to compute generic axes rotation. First of all, we need to load both this package and an ephemeris reader. The latter will be used to compute the orientation of the Moon&#39;s Principal Axes (PA) 440, whose Euler angles are defined in binary PCK kernels and to retrieve the positions of the planets. In this example, we will use our own <a href="https://github.com/JuliaSpaceMissionDesign/Ephemerides.jl">Ephemerides.jl</a> package and download the kernels from NAIF&#39;s website.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Ephemerides, Downloads</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; url_pck = &quot;https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; url_spk = &quot;https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eph = EphemerisProvider([Downloads.download(url_spk), Downloads.download(url_pck)])</code><code class="nohighlight hljs ansi" style="display:block;">2-kernel EphemerisProvider:
 &quot;/tmp/jl_xGJaLOnQt2&quot;
 &quot;/tmp/jl_zE1gxOFg90&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; G = FrameSystem{3, Float64}(eph)</code><code class="nohighlight hljs ansi" style="display:block;">FrameSystem{3, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(
  eph: 2-kernel EphemerisProvider,
  points: EMPTY
  axes: EMPTY
)</code></pre><p>To initialise the axes computational graph, a set of root axes must be initially registered. These will serve as the uppermost node of the graph and have no parents, meaning their orientation is not specified. Only inertial axes can be used as root axes of the <a href="../../Modules/frames_api/#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a>. </p><p>Before registering the axes, the <a href="../../Modules/frames_api/#FrameTransformations.Frames.@axes"><code>@axes</code></a> macro is used to define an acronym, an ID and a name of each set of axes that we wish to register in the system. If a name is not provided, a default one is used. In this example, we will use the <code>ICRF</code> as our base root inertial axes.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_inertial!(G, ICRF)</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Once a set of root axes has been registered, any other type of axes can be added to the system.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For standard applications, it is good practice that the axes&#39;s IDs are as in agreement with NAIF&#39;s numbering system. A list of IDs for the most common axes is provided in the Orient submodule.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the axes are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning. For instance, one could register a set of rotating axes named <code>ICRF</code>.</p></div></div><h2 id="Inertial-Axes"><a class="docs-heading-anchor" href="#Inertial-Axes">Inertial Axes</a><a id="Inertial-Axes-1"></a><a class="docs-heading-anchor-permalink" href="#Inertial-Axes" title="Permalink"></a></h2><p>Inertial axes are those that are fixed with respect to the star background. They are the only ones that can be used as root axes in the frame system but can also be defined through a relative orientation with respect to another set of inertial axis. </p><p>In this example, we register the <code>ECLIPJ2000</code> as a set of inertial axes with respect to the <code>ICRF</code>. Since the set of root axes has already been defined, all the future usages of the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_axes_inertial!"><code>add_axes_inertial!</code></a> function require a parent set of axes and a DCM with the relative orientation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes ECLIPJ2000 17</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_inertial!(G, ECLIPJ2000; parent=ICRF, dcm=DCM_ICRF_TO_ECLIPJ2000)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = rotation6(G, ICRF, ECLIPJ2000, 10.0)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([0.9999999999999941 -9.698854433992582e-8 4.57581833871911e-8; 7.078368694637674e-8 0.9174820489188898 0.3977771862633533; -8.05621421162006e-8 -0.3977771862633478 0.9174820489188915], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R[1]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  1.0         -9.69885e-8  4.57582e-8
  7.07837e-8   0.917482    0.397777
 -8.05621e-8  -0.397777    0.917482</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R[2]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>Notice that we leveraged the default DCM provided by Orient&#39;s to express the relative orientation between the <code>ICRF</code> and the <code>ECLIPJ2000</code>. For a set of default DCM exported by Orient, check the <a href="../../Modules/orient_api/#orient_dcms">API documentation</a>. Additionally, since it is an inertial frame, the time derivative of the rotation is null. </p><h2 id="Fixed-offset-Axes"><a class="docs-heading-anchor" href="#Fixed-offset-Axes">Fixed-offset Axes</a><a id="Fixed-offset-Axes-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-offset-Axes" title="Permalink"></a></h2><p>Fixed-offset axes have a constant orientation with respect to their parent axes in time. We previously saw that inertial axes can also be used to define axes with a fixed orientation with respect to their parents. However, while inertial axes do not rotate with respect to the star background, fixed offset axes are only constant with respect to their parent axes, but might be rotating with respect to some other inertial axes.</p><p>In this example, we register <code>FO1</code> as a set of axes with a fixed rotation of <code>π/4</code> around the Z-axis with respect to the <code>ICRF</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes FO1 2</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rot = angle_to_dcm(π/4, :Z)</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  0.707107  0.707107  0.0
 -0.707107  0.707107  0.0
  0.0       0.0       1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_fixedoffset!(G, FO1, ICRF, rot)</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>The state rotation matrix can then be obtained as: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = rotation6(G, ICRF, FO1, 86400)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([0.7071067811865476 0.7071067811865475 0.0; -0.7071067811865475 0.7071067811865476 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R[1]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
  0.707107  0.707107  0.0
 -0.707107  0.707107  0.0
  0.0       0.0       1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R[2]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>Since <code>FO1</code> has a constant orientation with respect to the <code>ICRF</code>, the time derivative of the rotation matrix <code>R[2]</code> is infact null. For further information see the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_axes_fixedoffset!"><code>add_axes_fixedoffset!</code></a> documentation.</p><h2 id="rot_axes"><a class="docs-heading-anchor" href="#rot_axes">Rotating Axes</a><a id="rot_axes-1"></a><a class="docs-heading-anchor-permalink" href="#rot_axes" title="Permalink"></a></h2><p>Rotating axes are generic, time-dependant, non-inertial axes. In order to register this kind of axes, a function (and optionally its derivatives) that expresses the relative orientation of this axes must be defined. This function shall return a Direction Cosine Matrix (DCM), available from the <a href="https://github.com/JuliaSpace/ReferenceFrameRotations.jl">ReferenceFrameRotations.jl</a> package.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes RotAx 3</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fun(t) = angle_to_dcm(-t, :Z)</code><code class="nohighlight hljs ansi" style="display:block;">fun (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_rotating!(G, RotAx, FO1, fun)</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>If we now compute the orientation between the <code>ICRF</code> and <code>RotAx</code> at <code>π/4</code> we obtain an identity rotation, since the orientation of <code>RotAx</code> is directed in the opposite direction of <code>FO1</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; R1 = rotation6(G, ICRF, RotAx, π/4)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], [0.0 -1.0 0.0; 1.0 0.0 0.0; 0.0 0.0 0.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R1[1]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R2 = rotation6(G, ICRF, RotAx, π/2)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([0.7071067811865475 -0.7071067811865476 0.0; 0.7071067811865476 0.7071067811865475 0.0; 0.0 0.0 1.0], [-0.7071067811865476 -0.7071067811865475 0.0; 0.7071067811865475 -0.7071067811865476 0.0; 0.0 0.0 0.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R2[2]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 -0.707107  -0.707107  0.0
  0.707107  -0.707107  0.0
  0.0        0.0       0.0</code></pre><p>Notice that, although we only provided a function that expresses the relative orientation, the frame system has automatically computed its time-derivative via Automatic Differentiation (AD) of <code>fun</code>. This becomes particularly useful for rapid prototyping or when the manual differentiation requires a lot of time. The functions for higher-order derivatives, must return the original DCM and its derivatives up to their orders. For example: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes RotAx2 4</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fun(t) = angle_to_dcm(-t, :Z)</code><code class="nohighlight hljs ansi" style="display:block;">fun (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dfun(t) = (angle_to_dcm(-t, :Z), Utils.angle_to_δdcm([-t, -1], :Z))</code><code class="nohighlight hljs ansi" style="display:block;">dfun (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_rotating!(G, RotAx2, FO1, fun, dfun)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R2 = rotation6(G, ICRF, RotAx2, π/2)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([0.7071067811865475 -0.7071067811865476 0.0; 0.7071067811865476 0.7071067811865475 0.0; 0.0 0.0 1.0], [-0.7071067811865476 -0.7071067811865475 0.0; 0.7071067811865475 -0.7071067811865476 0.0; 0.0 0.0 0.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R2[2]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 -0.707107  -0.707107  0.0
  0.707107  -0.707107  0.0
  0.0        0.0       0.0</code></pre><p>We can see the results are in agreement with the previous example. For more details, consult the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_axes_rotating!"><code>add_axes_rotating!</code></a> documentation.</p><h2 id="Projected-Axes"><a class="docs-heading-anchor" href="#Projected-Axes">Projected Axes</a><a id="Projected-Axes-1"></a><a class="docs-heading-anchor-permalink" href="#Projected-Axes" title="Permalink"></a></h2><p>Projected axes are a particular type of inertial axes. In this case the rotation is built by means of a time dependant function <code>f(t)</code>. However, all the derivatives of <code>f(t)</code> are assumed to be zero. This axes type is usually used to build True-of-Date (TOD) axes sets. </p><p>In this example, we illustrate this difference by registering two new set of axes with the same relative orientation with respect to the <code>ICRF</code>, one rotating and one projected. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes ProjAx 500</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes RotAx3 501</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fun(t) = angle_to_dcm(-t, :Z)</code><code class="nohighlight hljs ansi" style="display:block;">fun (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_rotating!(G, RotAx3, ICRF, fun)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_projected!(G, ProjAx, ICRF, fun)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R1 = rotation6(G, ICRF, RotAx3, 50.0)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([0.9649660284921133 0.26237485370392877 0.0; -0.26237485370392877 0.9649660284921133 0.0; 0.0 0.0 1.0], [0.26237485370392877 -0.9649660284921133 0.0; 0.9649660284921133 0.26237485370392877 0.0; 0.0 0.0 0.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R2 = rotation6(G, ICRF, ProjAx, 50.0)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([0.9649660284921133 0.26237485370392877 0.0; -0.26237485370392877 0.9649660284921133 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0]))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R1[1] - R2[1]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R1[2]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 0.262375  -0.964966  0.0
 0.964966   0.262375  0.0
 0.0        0.0       0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R2[2]</code><code class="nohighlight hljs ansi" style="display:block;">DCM{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><p>As you can see, while the relative orientation <code>R[1]</code> is equal, the time-derivative of the projected-axes orientation is null. For further information see the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_axes_projected!"><code>add_axes_projected!</code></a> documentation.</p><h2 id="Computable-Axes"><a class="docs-heading-anchor" href="#Computable-Axes">Computable Axes</a><a id="Computable-Axes-1"></a><a class="docs-heading-anchor-permalink" href="#Computable-Axes" title="Permalink"></a></h2><p>Computable axes are a kind of <em>time-dependant axes</em>. In this case, differently from the rotating axes, the axes and their derivatives are computed through two time-dependant vectors which are expressed using any type of point that is registered in the system. These axes are the equivalent of SPICE&#39;s two-vector frames.</p><p>In this example, we will register two ephemeris points, the Solar system barycenter and the Sun. For more information on how this operation is performed, see the <a href="../t02_points/#tutorial_02_points">points tutorial</a>. The two vectors that generate the set of computable axes are defined with the <a href="../../Modules/frames_api/#FrameTransformations.Frames.ComputableAxesVector"><code>ComputableAxesVector</code></a> object, by specifing the vector center and target point and its order, i.e., whether we are interested in the position, velocity or acceleration of that vector. A symbol is used to specify which direction the vectors have to align with. </p><p>In this example, the axes are constructed with the X-axis parallel to the instantaneous SSB to Sun direction, whereas the secondary vector is chosen parallel to the SSB to Sun velocity vector (order 2). Then, the component of this vector orthogonal to the X-axis is used to create the Y-axis. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes SunFrame 600</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point SSB 0 SolarSystemBarycenter</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @point Sun 10 SunPoint</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_root!(G, SSB, ICRF)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_point_ephemeris!(G, Sun, SSB)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v1 = ComputableAxesVector(Sun, SSB, 1)</code><code class="nohighlight hljs ansi" style="display:block;">ComputableAxesVector(10, 0, 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v2 = ComputableAxesVector(Sun, SSB, 2)</code><code class="nohighlight hljs ansi" style="display:block;">ComputableAxesVector(10, 0, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_computable!(G, SunFrame, ICRF, v1, v2, :XY)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = rotation6(G, ICRF, SunFrame, 0.0)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{2, Float64}(([0.9307646313076896 0.3452349713257856 0.12037448101796602; -0.3646672694138606 0.8528460137376037 0.37372645005420435; 0.026362543976245705 -0.39174799479456546 0.9196947998382602], [-4.876410895608863e-9 1.1404444386663028e-8 4.997552250715579e-9; -1.24485977115153e-8 -4.583740451381578e-9 -1.686718623822076e-9; -3.054887777376799e-11 7.144454909647363e-11 3.1307782740910527e-11]))</code></pre><p>For further information see the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_axes_computable!"><code>add_axes_computable!</code></a> documentation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The center and target point can either be specified with their integer IDs or their name aliases. </p></div></div><h2 id="Ephemeris-Axes"><a class="docs-heading-anchor" href="#Ephemeris-Axes">Ephemeris Axes</a><a id="Ephemeris-Axes-1"></a><a class="docs-heading-anchor-permalink" href="#Ephemeris-Axes" title="Permalink"></a></h2><p>Ephemeris axes a are a type of time-dependent axes which are build by means of Euler angles contained within a binary PCK ephemeris kernel. For example, in practice these are used to express the orientation of high-accuracy Lunar body-fixed frames (i.e., the Principal Axes) or the Earth&#39;s ITRF.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To properly compute the orientation of these axes, the <a href="../../Modules/frames_api/#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object must contain an ephemeris provider that has loaded the necessary PCK kernels. Additionally, in this case the ID of the registered axes must match the ID contained in the PCK kernels. </p></div></div><p>In this example, the ephemeris provider <code>eph</code> in the frame system <code>G</code> has loaded the DE421 PCK kernel containing the orientation of the Moon&#39;s Principal Axes (PA421). NAIF&#39;s system has assigned to such set of axes the ID <code>31006</code>. If a different ID was assigned to the <code>MoonPA</code>, the function would have thrown an error. A set of default axes IDs is also defined within the <a href="../../Modules/orient_api/#orient_axesid">Orient</a>&#39;s submodule for ease of use.</p><p>The function also requires the user to specify the rotation sequence to convert the Euler angles to a proper rotation matrix.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @axes MoonPA 31006</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_axes_ephemeris!(G, MoonPA, :ZXZ)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = rotation9(G, ICRF, MoonPA, 86400.0)</code><code class="nohighlight hljs ansi" style="display:block;">Rotation{3, Float64}(([0.6219855961037569 0.7077415949385507 0.33501604891898906; -0.7827096425059984 0.5741656785808802 0.24020697131409327; -0.022350252069861617 -0.4116255681242284 0.911078952615425], [-2.0835792981059603e-6 1.5281546248856286e-6 6.400222345301864e-7; -1.6557195262995373e-6 -1.8840097087356063e-6 -8.917889621565607e-7; -3.880601321351557e-10 -4.740262874274574e-10 -2.236848750095691e-10], [-4.407703819959643e-12 -5.014536010737041e-12 -2.3750017657161296e-12; 5.546289270719377e-12 -4.068112024772315e-12 -1.7038759932684681e-12; 2.130250244357035e-15 -4.0450577593420844e-17 3.3516097976061354e-17]))</code></pre><p>For further information see the <a href="../../Modules/frames_api/#FrameTransformations.Frames.add_axes_ephemeris!"><code>add_axes_ephemeris!</code></a> documentation.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t00_frames/">« 01 - Frame System</a><a class="docs-footer-nextpage" href="../t02_points/">03 - Points »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Saturday 30 September 2023 06:10">Saturday 30 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
